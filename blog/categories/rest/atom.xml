<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rest | Since 1975]]></title>
  <link href="http://ritalin.github.io/blog/categories/rest/atom.xml" rel="self"/>
  <link href="http://ritalin.github.io/"/>
  <updated>2015-03-20T01:20:28+09:00</updated>
  <id>http://ritalin.github.io/</id>
  <author>
    <name><![CDATA[ktz_alias]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(9)]]></title>
    <link href="http://ritalin.github.io/2015/03-19/restful-web-api-memo-09/"/>
    <updated>2015-03-19T23:00:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-19/restful-web-api-memo-09</id>
    <content type="html"><![CDATA[<h2>Chapter 9. The Design Procedure</h2>

<ul>
<li>API設計とは、プロトコルセマンティクスとアプリケーションセマンティクスを設計すること</li>
</ul>

<!-- more -->

<h3>最も単純な手順</h3>

<ol>
<li>表現として使用するmedia-typeを選択する

<ul>
<li>プロトコルセマンティクスとアプリケーションセマンティクスを選択することでもある</li>
<li>application/json

<ul>
<li>今日、幅広く使われている形式</li>
<li>fiat standardとなるので再利用出来ない</li>
</ul></li>
</ul></li>
<li>Profileを用意する</li>
</ol>

<h3>詳細な手順</h3>

<ol>
<li>クライアントがAPIを通して、get/putする情報の素片をリストアップする

<ul>
<li>情報の素片は階層構造をもったsemantic descriptor (リソースの表現) となる

<ul>
<li>この時点では、用語のブレは気にしない(first-name, first_name)</li>
</ul></li>
<li>語彙は、データベーススキーマやオブジェクトモデルからはもってこないこと

<ul>
<li>クライアントコードがサーバーサイドに依存してしまうため</li>
</ul></li>
<li>media-type在りきでデータ構造を決定しないこと

<ul>
<li>6. まで我慢する</li>
</ul></li>
<li>IANA登録済みのlink relationと重複させないこと

<ul>
<li>ページネーション

<ul>
<li>first, next, current</li>
<li>next-archive, prev-archive (RFC5005)</li>
</ul></li>
<li>メッセージスレッド

<ul>
<li>replies (RFC4685)</li>
</ul></li>
<li>リソース状態の履歴管理(RFC5829)

<ul>
<li>latest-version</li>
<li>successor-version</li>
<li>predecessor-version</li>
<li>working-copy</li>
<li>working-copy-of</li>
</ul></li>
<li>リソース状態の編集

<ul>
<li>edit</li>
<li>edit-media</li>
</ul></li>
</ul></li>
</ul></li>
<li>APIの状態遷移図を描く

<ul>
<li>一つの状態に一つの表現を割り当てる</li>
<li>一つの状態遷移が一つの矢印となる</li>
<li>httpメソッドはまだ割り当てない</li>
<li>冪等性と安全性は考えておくべき</li>
<li>link relationが発見されるかもしれない

<ul>
<li>構造化された内と外との間のリンク</li>
<li>用語がアプリケーション状態の変化をもたらすのであれば、その用語はリレーション</li>
<li>拡張リンクリレーション

<ul>
<li>http://example.com/maze#exit</li>
<li>profile取り込むことなく使用可能</li>
</ul></li>
</ul></li>
<li>階層構造が変化するかもしれない</li>
<li>状態間は、グループ化されたdescriptor (ValueObject)が行き来する</li>
<li>状態遷移におけるトップレベル表現を設ける

<ul>
<li>ほかの状態へは、ハイパーメディアコントロールを通して</li>
</ul></li>
</ul></li>
<li>semantic descriptorとlink relationが満足するまで、1, 2を繰り返す

<ol>
<li>用語のブレは解消しておくこと</li>
</ol></li>
<li>用語が既知のprofileに存在するのなら、それに置き換える

<ul>
<li>IANAに登録されたリレーション</li>
<li>schema.orgに登録された用語</li>
<li>alps.ioに登録された用語</li>
<li>ドメイン特化フォーマットで使用される用語、などなど</li>
<li>既知の語彙は間違った理解を減らせる</li>
<li>profileの再利用は、書くべきドキュメント量を減らせる</li>
<li>profileの再利用は、ライブラリの再利用を促せる</li>
<li>たいていはprofileを使用せず、media-typeに結びつけてしまっている

<ul>
<li>一つのAPIに対して複数のmedia-typeを独自定義せず、複数のprofileを利用する</li>
</ul></li>
<li>金融、法務関係のprofileは、未整備のため再利用は難しい</li>
</ul></li>
<li>用語と状態遷移図が満足するまで、1 - 3を繰り返す</li>
<li>プロトコルセマンティクスとアプリケーションセマンティクスに適合するmedia-typeを選択する

<ul>
<li>運が良ければ、ドメイン特化フォーマットが見つかるかもしれない</li>
<li>独自定義する場合、標準的な命名規則に従う

<ul>
<li>application/vnd.(org name).(base type)</li>
<li>(例) application/vnd.hoge.maze+xml</li>
</ul></li>
<li>より汎用的な利用を考えているのならIANAにmedia-typeを登録する

<ul>
<li>RFC6838の4, 5節の手順に従う</li>
<li>JSONベースならRFC4627を目を通すべし</li>
<li>XMLベースならRFC3023に目を通すべし</li>
</ul></li>
<li>可能な限り、ハイパーメディアフォーマットを選択する</li>
<li>コレクションパターン

<ul>
<li>Collection+JSON</li>
<li>AtomPub</li>
<li>OData</li>
</ul></li>
<li>有向グラフ構造

<ul>
<li>HTML</li>
<li>HAL</li>
<li>Siren</li>
</ul></li>
<li>読み取り専用API

<ul>
<li>HTML</li>
<li>HAL</li>
<li>JSON-LD</li>
</ul></li>
<li>安全でないメソッドを使用する場合

<ul>
<li>Hydra</li>
<li>Collection+JSON</li>
</ul></li>
</ul></li>
<li>未知の用語に対して、profileを用意する

<ul>
<li>machine-readable フォーマット

<ul>
<li>Alps<br></li>
<li>JSON-LD</li>
<li>XMDPベースのwebページ</li>
</ul></li>
<li>profileでlink relationを定義した場合、IANAのものよりも優先される

<ul>
<li>意図的にやるべきではない</li>
</ul></li>
</ul></li>
<li>状態遷移図を満たすサーバー実装を書く</li>
<li>トップのURLを公開する

<ul>
<li>状態遷移図のゲートウェイをトップURLとする</li>
<li>Profileを配置する

<ul>
<li>自サイト</li>
<li>alps.io</li>
</ul></li>
<li>APIの要約</li>
<li>利用例</li>
<li>サンプルコード</li>
<li>認証手順</li>
<li>Well known URIs Registry (RFC5785)

<ul>
<li>CoRE Link Formatの場合

<ul>
<li>/.well-knoen/coreに問い合わせ</li>
<li>相対URLは、IANAレジストリに登録</li>
<li>ほかリソースのハイパーメディアリンクの一覧を取得できる</li>
</ul></li>
<li>ホストメタデータの取得

<ul>
<li>/.well-known/host-meta.json </li>
<li>または、/.well-known/host-meta</li>
</ul></li>
<li>well known URIは、media-typeに関連付けられる</li>
</ul></li>
</ul></li>
</ol>

<h3>バージョニング</h3>

<ul>
<li>前提

<ul>
<li>第一にAPIのセマンティクスをhuman-readableドキュメントやハイパーメディアドキュメントの外に置くこと
*　変更に強くなる</li>
<li>既存のリソース定義を変更するのではなく、新しいリソースや状態遷移を追加するに留める</li>
</ul></li>
<li>URLに付与

<ul>
<li><li class="v1" href="v1" />のような感じ</li>
<li>media-typeに付与

<ul>
<li>コンテントネゴシエーションとして指定

<ul>
<li>Accept: application/vnd.hoge?version=2

<ul>
<li>media-typeはAPIではないのでやめといた方がいい</li>
</ul></li>
</ul></li>
</ul></li>
<li>profileを使う

<ul>
<li>破壊的変更はhuman-readableに記述</li>
<li>非破壊変更はmachine-readableなハイパーメディアで記述</li>
</ul></li>
<li>リソーススキーマの変更

<ul>
<li>後方互換性を保ちたいなら、異なるURIを持つ新たなリソースを定義する</li>
</ul></li>
</ul></li>
</ul>

<h3>古いAPIの止め方</h3>

<ol>
<li>deplecatedをマークし、公式チャンネルでアナウンスする</li>
<li>しばらくしたら、deplecatedマークしたバージョンはバグ修正しないことをアナウンスする</li>
<li>更に幾つか待って、停止の期限をアナウンスする</li>
<li>停止日が訪れたら、古いAPIのリクエストに対し、410(Gone)を返し、新しいAPIへのリンク先を案内する</li>
</ol>

<h3>既存のAPIをRESTfulにする場合</h3>

<ul>
<li><p>WSDL</p>

<ul>
<li>非RESTful API</li>
<li>サーバー実装と自動生成されるクライアント実装が密結合となる</li>
<li>サーバー実装の変更をクライアントサイドに反映出来ない</li>
</ul></li>
<li><p>既存のJSONベースAPIにハイパーメディアを追加する場合</p>

<ul>
<li>名前(application descriptor) を変更しない</li>
<li>media-typeを変更しない</li>
<li>安全でないリレーションを追加する場合、profileとしてHydraをもつJSON-LDがオススメ</li>
</ul></li>
<li><p>既存のXMLベースのAPIにハイパーメディアを追加する場合</p>

<ul>
<li>XFirn, XLinkをハイパーメディアコントロールとして使用する</li>
</ul></li>
<li><p>たとえわけの分からないレスポンスだったとしても</p>

<ul>
<li>media-typeやrelationがIANAに登録されている</li>
<li>profileドキュメントへのリンクがあれば、なんとか解析はできる

<ul>
<li>profileはmachine-readableに加えて、human-readableな情報があると尚よし</li>
</ul></li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(8)]]></title>
    <link href="http://ritalin.github.io/2015/03-11/restful-web-api-memo-08/"/>
    <updated>2015-03-11T23:26:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-11/restful-web-api-memo-08</id>
    <content type="html"><![CDATA[<h2>Chapter 8. Profiles</h2>

<ul>
<li>アプリケーション特化の拡張機能に対するドキュメント化</li>
<li><p>アプリケーション特化の用語の定義、ドキュメント化</p></li>
<li><p>現在、一般的用いられていることは、大量のhuman-readableなドキュメントを作成すること</p>

<ul>
<li>APIドキュメントについてはRESTful(自己記述性メッセージ)でない</li>
</ul></li>
</ul>

<!-- more -->

<h3>クライアントアプリはいかにしてドキュメントをさがすのか？</h3>

<ul>
<li><p>クライアントがリクエストやレスポンスの意味を推測すべきではない</p>

<ul>
<li>メッセージ自身が、詳細に説明すべき</li>
</ul></li>
<li><p>レスポンスはクライアントがなすべきことを全て含めるべき</p>

<ul>
<li>Content-type

<ul>
<li>リソースの解析方法を示す</li>
</ul></li>
<li>ハイパーメディアコントロール

<ul>
<li>次に発行すべきリクエストをレスポンスに含める</li>
<li>プロトコルセマンティクスを明示する</li>
</ul></li>
<li>ドメイン特化フォーマットの場合

<ul>
<li>リソースに問題領域の状態遷移を含める</li>
<li>アプリケーションセマンティクスを付与する</li>
</ul></li>
</ul></li>
<li><p>多くの場合、プロトコルセマンティクスとアプケーションセマンティクスの両方をフォーマットから読み取ることはできない</p>

<ul>
<li>仕様Profileが欠損している</li>
</ul></li>
</ul>

<h3>Profile</h3>

<ul>
<li><p>media-typeを元にリソースを解析しても得られない仕様(APIドキュメント)</p>

<ul>
<li>たいていHuman-readableな文書</li>
<li>machine-readable profile

<ul>
<li>linkやdescripterで記述されたhuman-readableなドキュメント(Profile)を自動収集できる</li>
</ul></li>
</ul></li>
<li><p>定義(RFC6906)</p>

<ul>
<li>リレーションを使用してProfileとリンク(rel=&quot;profile&quot;)

<ul>
<li>IANAにそのリレーションが登録されている

<ul>
<li>relをサポートするあらゆるハイパーメディアコントロールで利用可能

<ul>
<li>htmlのaタグ</li>
<li>html, Collection+JSON, HALのlinkタグ</li>
<li>RFC5988のLINKヘッダ</li>
</ul></li>
</ul></li>
<li>Ontent-Typeパラメータに追記

<ul>
<li>application/collection+json;profile=&quot;(リンク先URL)&quot;</li>
<li>すべてのmedia-typeで使用できるわけではない(RFC4288)

<ul>
<li>Collection+JSON</li>
<li>JSON-LD</li>
<li>HAL</li>
<li>XHTML</li>
</ul></li>
<li>httpヘッダでprofileリンクを示したいなら、すべてで使えるLINKヘッダを使うべき</li>
</ul></li>
<li>Microdataのitemtype

<ul>
<li>Urlで、リンク先のprofileを指定する</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h3>プロトコルセマンティクスProfile</h3>

<ul>
<li>どのようなHTTPリクエスト発行されるのかについて</li>
<li>フリーフォームな文体で記述</li>
<li>ハイパーメディアコントロールを持たないmedia-type(JSON)に対して用意</li>
<li>HALのようにプロトコルセマンティクスが削ぎ落とされている場合に用意</li>
<li>ハイパーメディアコントロールであれば、リンクリレーションを用いて指定

<ul>
<li>ハイパーメディアコントロールから駆動される状態遷移を記述した文字列

<ul>
<li>GETでアプリケーション状態を遷移</li>
<li>POST, PUT,DELETEでリソース状態を遷移</li>
</ul></li>
</ul></li>
</ul>

<h3>アプリケーションセマンティクスProfile</h3>

<ul>
<li><p>人が用語を理解するようにコンピュータにも理解させること</p></li>
<li><p>利用するデータ構造、パラメータなどの説明文を用意</p></li>
<li><p>用語をセマンティクス記述子に表記</p>

<ul>
<li>microformats

<ul>
<li>class属性</li>
</ul></li>
<li>Siren

<ul>
<li>classエンティティ</li>
</ul></li>
<li>生JSON

<ul>
<li>オブジェクトキー</li>
</ul></li>
<li>生XML

<ul>
<li>タグ名</li>
</ul></li>
</ul></li>
</ul>

<h3>XMDP</h3>

<ul>
<li>machine-readable profileの一種</li>
<li>ほかのmicroformatを説明するためのmicroformat</li>
<li>class属性に特別な意味があることを伝えられる

<ul>
<li>自動的に理解するわけではなく、そんなツールを書く必要がある</li>
</ul></li>
</ul>

<h3>ALPS</h3>

<ul>
<li>XMDP同様、meta-microformst</li>
<li>HTML専用</li>
<li>プロパティ

<ul>
<li>descriptor

<ul>
<li>一つの用語に対して一つ作る</li>
<li>type=&quot;semantic&quot;</li>
<li>子要素のdocタグにhuman-readableな説明を書く</li>
<li>docタグ以外はmachine-readable</li>
<li><descripter href="#fn" />のようにすることで、ハイパーメディアコントロールにすることもできる</li>
</ul></li>
</ul></li>
</ul>

<h3>JSON-LD</h3>

<ul>
<li>元のJSONドキュメントに&quot;context&quot;と呼ばれるmachin-readableドキュメントを組み込む</li>
<li>APIの変更なしに組み込むことが可能</li>
<li>RDFからの派生</li>
<li>アプリケーションセマンティクスを直接説明せず、ハイパーメディアリンクを添えるだけ

<ul>
<li>&quot;n&quot;: <url></li>
<li>&quot;photo_link&quot;: { &quot;@id&quot;: <url>, &quot;@type&quot;: &quot;@id&quot; }</li>
</ul></li>
</ul>

<h3>API自身にドキュメントを埋め込む</h3>

<ul>
<li><p>APIにhuman-readableドキュメントを埋め込めるフォーマットを用いる</p>

<ul>
<li>HTML

<ul>
<li>inputタグのvalue属性</li>
</ul></li>
<li>HAL

<ul>
<li>linkタグのtitle属性</li>
</ul></li>
<li>Siren

<ul>
<li>actionオブジェクトのtitleフィールド</li>
</ul></li>
</ul></li>
<li><p>machine-readableとhuman-readableドキュメントの両方を用意することについて</p>

<ul>
<li>人との対話により動くクライアント、自動化クライアントの両対応のため</li>
<li>両方のセマンティクスギャップをより縮める</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="/2015/03-19/restful-web-api-memo-09/">RESTful Web APIs 読書メモ(9)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(7)]]></title>
    <link href="http://ritalin.github.io/2015/03-09/restful-web-api-memo-07/"/>
    <updated>2015-03-09T21:08:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-09/restful-web-api-memo-07</id>
    <content type="html"><![CDATA[<h2>Chapter 7. Pure hypermedia Design</h2>

<ul>
<li>コレクションパターンは強力であるが、何でもかんでも使えるではない</li>
<li><p>MAZE+xmlのコレクションパターンでの表現（5章）</p>

<ul>
<li>どう見ても迷路ゲームのアプリケーションセマンティクスにマッチしていない</li>
</ul></li>
<li><p>APIの設計方針として、汎用的なハイパーメディアを用いることができる</p></li>
</ul>

<!-- more -->

<h3>HTML</h3>

<ul>
<li>多くのOS標準搭載されたブラウザにレンダリングさせてデバッグできる</li>
<li>XMLやJSONよりも、よりドキュメントとしての構造を強いている</li>
<li>標準化されたハイパーメディアコントロールを有している

<ul>
<li>formタグ(method=&quot;GET&quot; = outbound link

<ul>
<li>inputタグによるURIテンプレート代替</li>
</ul></li>
<li>formタグ(method=&quot;POST&quot; = リソース生成依頼</li>
<li>linkタグ(rel=&quot;stylesheet&quot;) = embedded link</li>
<li>linkタグ(rel=&quot;self&quot;) = outbound link</li>
<li>aタグ = outbound link</li>
<li>imgタグ、scriptタグ = embedded link</li>
<li>特別な問題領域に特化したものではない</li>
</ul></li>
<li><p>解析 / 生成のためのツールが多くある</p></li>
<li><p>データ構造としてのHTML</p>

<ul>
<li>ol = JSON順序リスト</li>
<li>ul = JSON非順序リスト</li>
<li>dl = JSONオブジェクト</li>
<li>table = 二次元配列</li>
<li>div/span = グループ化</li>
</ul></li>
<li><p>汎用属性</p>

<ul>
<li>rel

<ul>
<li>IANAに登録されたリレーションを用いることで、HTMLにアプリケーションセマンティクスを組み込める</li>
</ul></li>
<li>id

<ul>
<li>文書内で一意の識別子</li>
<li>idでアプリケーションセマンティクスをフックするのはオススメではない

<ul>
<li>複数の文書をマージしたい場合に一意性が保証出来ないため</li>
</ul></li>
</ul></li>
<li>class

<ul>
<li>最も柔軟性のある属性</li>
<li>wwwではcssによるフォーマッティングに用いられる</li>
<li>アプリケーションセマンティクスとしては、グループ化のタグとして用いることができる</li>
</ul></li>
</ul></li>
</ul>

<h3>microformat</h3>

<ul>
<li>htmlにアプリケーションセマンティクスを付与する技術</li>
<li>classとrel属性に与える値のみを定義する</li>
<li>html + microformatでドメイン特化なフォーマットを再現できる</li>
<li>hCard

<ul>
<li>グループ化やフィールドのためのclassのみが定義されている</li>
<li>hCard自身はハイパーメディアコントロールではないが、htmlから拝借して、connectednessを実現できる</li>
<li>どのhtmlタグに付けるかは自由</li>
<li>vCard(RFC6350)を元にしている

<ul>
<li>ハイパーメディアコントロールではない</li>
</ul></li>
</ul></li>
</ul>

<h3>Microdata</h3>

<ul>
<li>html5用、microformat改良版</li>
<li>総本山はschema.org</li>
<li>microformstにおけるclassの置き換え</li>
<li>リレーションは定義出来ない</li>
<li>class属性は本来、アプリケーションセマンティクスを体現する場ではない</li>
<li>プロパティ

<ul>
<li>itemprop

<ul>
<li>グループ名、フィールド名の定義</li>
</ul></li>
<li>itemscope

<ul>
<li>Microdataによる表現を開始するタグに付与</li>
</ul></li>
<li>itemtype

<ul>
<li>付与したタグをハイパーメディアコントロールにする</li>
<li>値はURL</li>
</ul></li>
<li>itemid</li>
<li>itemref</li>
</ul></li>
</ul>

<h3>フォームにアプリケーションセマンティクスを加えること</h3>

<ul>
<li><p>リンクリレーションは、リソース間の関連を記述するもの</p>

<ul>
<li>自身と同じURLに異なるリンクリレーションのリンクを貼る =&gt; リソース状態が変更されることを意味する</li>
<li>リンクはGETリクエストの発行となるため、HTTPメソッドの制約に反する</li>
</ul></li>
<li><p>HTMLフォームなら、POSTリクエストを発行できる</p>

<ul>
<li>リソース状態を変更することは制約に反しない</li>
<li>inputタグのclass属性にアプリケーションセマンティクスとなる用語を与える</li>
<li>アクションURLを組み立てるためのテンプレートは不要

<ul>
<li>formタグがアクションURLを持つため</li>
</ul></li>
<li>sublitタイプのinputタグを置いて初めて、状態遷移が可能となる

<ul>
<li>遷移させたくなければ、sublitを置く必要はない</li>
</ul></li>
</ul></li>
<li><p>リソース指向アプローチ</p>

<ul>
<li>リソースを識別し、そこにハイパーメディアを試みる作り</li>
<li>まずリソースを識別することに重きを置いている</li>
</ul></li>
<li><p>ハイパーメディア設計</p>

<ul>
<li>リソースを識別することよりも状態遷移を識別することの方が重要</li>
</ul></li>
</ul>

<h3>HTMLの限界</h3>

<ul>
<li>本来のHTMLは、ハイパーメディアフォーマットなどではなく、human-readableに特化した標準</li>
<li>全てのhttpプロトコルを実現できない

<ul>
<li>PUT, DELETEはJavascriptの手助けが必要</li>
</ul></li>
<li>formで構成できるリクエストは、application/x-www-form-urlencodedか、multipart/form-dataのいずれか</li>
<li>文字列と数字を区別しない

<ul>
<li>そのアプリケーションセマンティクスはhtmlの外で定義するしかない</li>
</ul></li>
<li>日付表現を定義していない

<ul>
<li>vCardのbdayはISO8601として個別に定義</li>
</ul></li>
</ul>

<h3>html5</h3>

<ul>
<li>timeタグ

<ul>
<li>特定のフォーマットでdate型やtimestamp型を表現</li>
</ul></li>
<li>meterタグ

<ul>
<li>特定の範囲内の測定値を表現</li>
</ul></li>
<li>audioタグ</li>
<li>videoタグ</li>
<li>sourceタグ</li>
<li>embedタグ</li>
<li>inputタグのvalidation

<ul>
<li>値としてdate, number, urlを表現</li>
<li>required属性で必須入力</li>
<li>クライアントサイドバリデーション</li>
</ul></li>
<li>formタグ

<ul>
<li>texp/plainメディアタイプのサポート</li>
</ul></li>
<li>Microdata

<ul>
<li>classs属性への意味づけ</li>
</ul></li>
<li>PUT, DELETEは引き続き未サポート</li>
</ul>

<h3>Hypermedia Application Language (HAL)</h3>

<ul>
<li>media-type

<ul>
<li>application/hal+xml</li>
<li>application/hal+json</li>
</ul></li>
<li>要素としてresourceとlinkタグのみを定義されている</li>
<li>resourceタグ

<ul>
<li>httpリソースの表現</li>
</ul></li>
<li>link

<ul>
<li>これ一つであらゆるハイパーメディアを扱える

<ul>
<li>GET, POST, PUT, DELETE, UNLINK</li>
<li>プロトコルセマンティクスを指定するすべはない</li>
<li>リレーションの意味を明示的にドキュメントとして残すしかない</li>
</ul></li>
</ul></li>
</ul>

<h3>Siren</h3>

<ul>
<li>JSONベースのハイパーメディアフォーマット</li>
<li>HTMLとCollection+JSONの合いの子のような立ち位置</li>
<li>entities

<ul>
<li>データをグループ化</li>
<li>htmlのdivタグ相当</li>
<li>URLを付与することでサブリソースとして振舞わせられる</li>
<li>links

<ul>
<li>別のリソースへのリンク先を記述</li>
</ul></li>
</ul></li>
</ul>

<h3>Semantics Challenge</h3>

<ul>
<li>httpプロトコルセマンティクス

<ul>
<li>リソースにGET, POSTなどのリクエストメソッドを割り当てる</li>
</ul></li>
<li>ハイパーメディア

<ul>
<li>サーバーで次に行わせたいリクエストを伝える仕組み</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>アプリケーション状態やリソース状態をハイパーメディアで制御すること</li>
</ul></li>
<li>ドメイン特化フォーマット

<ul>
<li>例: Maze+XML</li>
<li>プロトコルセマンティクスを定義</li>
<li>アプリケーションセマンティクスも定義</li>
<li>稀な存在</li>
</ul></li>
<li>標準フォーマット

<ul>
<li>Collection+JSON, AtomPubなど</li>
<li>プロトコルセマンティクス詳細に定義している

<ul>
<li>item-typeリソース = PUTに応答</li>
</ul></li>
<li>アプリケーションセマンティクスは未定義</li>
</ul></li>
<li>microformat

<ul>
<li>アプリケーションセマンティクスを定義</li>
<li>プロトコルセマンティクスは未定義</li>
</ul></li>
<li>HTML, HAL, Siren

<ul>
<li>プロトコルセマンティクスを定義</li>
<li>アプリケーションセマンティクスも定義</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="/2015/03-11/restful-web-api-memo-08/">RESTful Web APIs 読書メモ(8)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(6)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-06/"/>
    <updated>2015-03-08T22:47:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-06</id>
    <content type="html"><![CDATA[<h2>Chapter 6. The Collection Pattern</h2>

<ul>
<li>コレクションもまたリソース

<ul>
<li>  コレクションに含まれるリソースは&quot;item&quot;や&quot;entry&quot;、&quot;member&quot;と呼ばれる</li>
</ul></li>
<li>  Pagenation

<ul>
<li>  大量のコレクションメンバーを持つ場合、全てを一度に返すことは通常しない</li>
<li>  最初の一部だけをコレクションとして返し、残りはrel=&quot;next&quot;を付与したリンクだけを提供する

<ul>
<li>  nextはIANAで登録されている</li>
<li>  ほかにprev, first, lastもIANAで定義されている</li>
</ul></li>
<li>  Collection+JSONはリレーションを明示的にサポートしてはいない

<ul>
<li>  必要ならリレーションを組み込めばいい</li>
</ul></li>
</ul></li>
</ul>

<!-- more -->

<h3>Collection+JSON</h3>

<ul>
<li>問題領域とは独立した汎用フォーマット</li>
<li>手軽にREST制約を組み込める</li>
<li>httpを介して取得するリソースのためのプロトコルセマンティクス</li>
<li>プロパティ

<ul>
<li>href

<ul>
<li>コレクション自身へのリンク</li>
</ul></li>
<li>items

<ul>
<li>コレクションの要素</li>
<li>アプリケーション特化データの集合

<ul>
<li>href

<ul>
<li>要素へのリンク</li>
<li>GETリクエストで単独のリソースとして取得できる</li>
<li>PUTやDELETEで変更、削除</li>
</ul></li>
<li>links

<ul>
<li>要素に関連するほかのリソースへのリンク</li>
<li>例えば、本リソースに対する著者、出版社等</li>
<li>render=&quot;link&quot;

<ul>
<li></li>
</ul></li>
<li>render=&quot;image&quot;

<ul>
<li></li>
</ul></li>
</ul></li>
<li>data

<ul>
<li>要素を構成する内容</li>
<li>アプリケーションセマンティクスの要</li>
<li>&quot;name&quot;と&quot;value&quot;から成るJSONオブジェクトの集合</li>
<li>各ペアには備考として&quot;prompt&quot;をもたせられる</li>
</ul></li>
</ul></li>
</ul></li>
<li>links

<ul>
<li>コレクションに関連するほかの要素</li>
</ul></li>
<li>queries

<ul>
<li>コレクションを検索するためのテンプレート</li>
</ul></li>
<li>templates

<ul>
<li>コレクションに新しい要素を加えるためのテンプレート</li>
</ul></li>
<li>error

<ul>
<li>エラーメッセージ</li>
</ul></li>
</ul></li>
</ul>

<h3>AtomPub</h3>

<ul>
<li>Atomフォーマット

<ul>
<li>RSSに代わり、ニュースを同報する仕組みとしてRFC4287で標準化</li>
<li>ニュース記事を一つ以上のカテゴリに分類できる</li>
</ul></li>
<li>AtomPubはニュースを編集 / 発行(CRUD)などを行うためのAtomフォーマットを使ったワークフロー(RFC5023)</li>
<li>media-typeはapplication/atom+xml</li>
<li>新しいエントリーはURIにPOSTすることで行う</li>
<li>リンクにrel=&quot;edit&quot;を付与することで編集可能なエントリーであることを示す(PUTサポート) </li>
<li>Collection+JSONと同じコンセプトをもつ

<ul>
<li>コレクション要素は&quot;item&quot; -&gt; &quot;feed&quot;</li>
<li>Collection+JSONは汎用フォーマットなので、itemに特別なアプリケーションセマンティクスわ定義していない</li>
<li>AtomPubはニュース配信プロトコルなので、エントリーはニュース記事</li>
</ul></li>
<li>コレクションパターンのプラグイン基盤としても用いられる

<ul>
<li>Atom Threading Extension

<ul>
<li>RFC4685</li>
<li>メールスレッド表現</li>
<li>rel=&quot;replies&quot;</li>
</ul></li>
<li>Atom deleted entry element

<ul>
<li>RFC6721</li>
<li>エントリーを削除するのではなく墓石を置削除扱いとする</li>
</ul></li>
<li>Feed Paging and Archiving

<ul>
<li>RFC5005</li>
<li>アーカイブフィードコンセプトを定義</li>
<li>複数のリソースをまたがるきょだなフィードをPagingする方法</li>
<li>rel属性として、next-archive, prev-archive, currentを使う</li>
</ul></li>
<li>OpenSearch

<ul>
<li>xmlベースの検索プロトコル標準</li>
<li>rel=&quot;search&quot;</li>
<li>Collection+JSONにおけるqueriesプロパティど同等のもの</li>
</ul></li>
<li>PubSubHubbub

<ul>
<li>Atomフィードが更新されたときに通知を行うためのプロトコル</li>
<li>rel=&quot;hub&quot;</li>
</ul></li>
<li>これらのリレーションは全てIANAに登録されている

<ul>
<li>何の説明もなく使用できる</li>
</ul></li>
</ul></li>
<li>プロパティ

<ul>
<li>feed

<ul>
<li>ID

<ul>
<li>一意的にニュースを識別するためのもの</li>
</ul></li>
<li>title

<ul>
<li>見出し</li>
</ul></li>
<li>subtitle</li>
<li>author</li>
<li>date, time

<ul>
<li>発行日時 / 最終更新日時</li>
</ul></li>
</ul></li>
</ul></li>
<li>アプリケーションセマンティクスのためにプロパティを拡張することが認められている

<ul>
<li>Googleでは、マップ上のシンボル、カレンダー、スプレッドシートのセル、ビデオ用に付加的な表現を拡張している(GData)</li>
</ul></li>
</ul>

<h3>OData</h3>

<ul>
<li>AtomPubベース</li>
<li>MSが協力しているのでVisual studioから使いやすい</li>
</ul>

<h3>Hydra</h3>

<ul>
<li>あまり表舞台では見かけない</li>
</ul>

<h3>Semantics Challenge</h3>

<ul>
<li><p>ドメイン特化なフォーマットの場合(MAZE+xml)</p>

<ul>
<li>カスタムタイプ、リンクリレーションがセマンティクスギャップを埋める

<ul>
<li>カスタム定義したハイパーメディアタイプ</li>
<li>問題空間のために定義されたリンクリレーション</li>
</ul></li>
</ul></li>
<li><p>コレクションパターンは2種類のリソースタイプに大別される</p>

<ul>
<li>item-type

<ul>
<li>GET, PUT, DELETE</li>
<li>内容+ item自身へのリンクをもつ</li>
</ul></li>
<li>collection-type

<ul>
<li>GET, POST(as append)</li>
<li>item-typeリソースをメンバーとしてもつ</li>
</ul></li>
</ul></li>
<li><p>collection-typeはリンクリレーションによるナビゲーションでアプリケーションセマンティクスを定義する</p>

<ul>
<li>first, next, search</li>
</ul></li>
<li><p>item-type</p>

<ul>
<li>一般的に定義されたアプリケーションセマンティクスはない</li>
<li>Collection+JSON

<ul>
<li>item-typeリソースの意味は、prompt要素にhuman-readableな説明として記述される</li>
</ul></li>
</ul></li>
<li><p>同じドメインでも、APIが異なれば、アプリケーションセマンティクスは異なる</p>

<ul>
<li>text or content</li>
<li>post ot blogPost</li>
<li>etc,&#8230;</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="/2015/03-09/restful-web-api-memo-07/">RESTful Web APIs 読書メモ(7)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ESTful Web APIs 読書メモ(5)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-05/"/>
    <updated>2015-03-08T22:19:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-05</id>
    <content type="html"><![CDATA[<h2>Chapter.5 Domain-Specific Designs</h2>

<ul>
<li> ドメイン特化設計

<ul>
<li>ドメイン特化のmedia-typeではなく、一般的なmedia-typeにアプリケーションセマンティクスを加える方が良い

<ul>
<li>Aplication/vnd.xxx.Maze+XML</li>
</ul></li>
<li>API設計する際に平均的な開発者が最初に選択する</li>
<li>RFC5988

<ul>
<li>リンク間の関係を定義</li>
</ul></li>
</ul></li>
</ul>

<!-- more -->

<ul>
<li>Maze+XMLでスタート地点を得るためにAPI callメタファを使うと

<ul>
<li>迷路一覧をGET

<ul>
<li>rel=&quot;maze&quot;で対象の迷路が判明</li>
</ul></li>
<li>対象の迷路をGET

<ul>
<li>rel=&quot;start&quot;でエントランスが判明</li>
</ul></li>
<li>迷路のエントランスセルをGET

<ul>
<li>relで各方角のセルが判明</li>
</ul></li>
</ul></li>
<li>API callメタファ

<ul>
<li>サーバーの実装の詳細が露出しがちになる</li>
<li>サーバーとクライアントが密結合となる</li>
<li>APIをおいそれと修正出来なくなる</li>
</ul></li>
<li><p>ドメイン特化API</p>

<ul>
<li>作成者

<ul>
<li>human-readableな仕様を書く</li>
<li>その仕様にmedia-typeを関連付けIANAに登録する</li>
</ul></li>
<li>利用者

<ul>
<li>IANAレジストリで未知のmedia-typeを探す</li>
<li>登録された仕様を読み、利用方法を学ぶ</li>
</ul></li>
</ul></li>
<li><p>クライアント</p>

<ul>
<li>human-driven</li>
<li>clawler

<ul>
<li>全てのハイパーメディアをたどる</li>
</ul></li>
<li>script

<ul>
<li>最初に遭遇したハイパーメディアのみをたどる</li>
</ul></li>
<li>monitor

<ul>
<li>ハイパーメディアを列挙する</li>
</ul></li>
<li>agent

<ul>
<li>アルゴリズムを基づき、ハイパーメディアを取捨選択する</li>
</ul></li>
</ul></li>
<li><p>自動化されたクライアントは、ハイパーメディアAPIのメリットを最も享受できる</p>

<ul>
<li>ゴールが見えている</li>
<li>ゴールへのみちが示されている</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="/2015/03-08/restful-web-api-memo-06/">RESTful Web APIs 読書メモ(6)</a></p>
]]></content>
  </entry>
  
</feed>
