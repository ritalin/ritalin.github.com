<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Since 1975]]></title>
  <link href="http://ritalin.github.io/atom.xml" rel="self"/>
  <link href="http://ritalin.github.io/"/>
  <updated>2015-03-20T02:13:08+09:00</updated>
  <id>http://ritalin.github.io/</id>
  <author>
    <name><![CDATA[ktz_alias]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(9)]]></title>
    <link href="http://ritalin.github.io/2015/03-19/restful-web-api-memo-09/"/>
    <updated>2015-03-19T23:00:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-19/restful-web-api-memo-09</id>
    <content type="html"><![CDATA[<h2>Chapter 9. The Design Procedure</h2>

<ul>
<li>API設計とは、プロトコルセマンティクスとアプリケーションセマンティクスを設計すること</li>
</ul>

<!-- more -->

<h3>最も単純な手順</h3>

<ol>
<li>表現として使用するmedia-typeを選択する

<ul>
<li>プロトコルセマンティクスとアプリケーションセマンティクスを選択することでもある</li>
<li>application/json

<ul>
<li>今日、幅広く使われている形式</li>
<li>fiat standardとなるので再利用出来ない</li>
</ul></li>
</ul></li>
<li>Profileを用意する</li>
</ol>

<h3>詳細な手順</h3>

<ol>
<li>クライアントがAPIを通して、get/putする情報の素片をリストアップする

<ul>
<li>情報の素片は階層構造をもったsemantic descriptor (リソースの表現) となる

<ul>
<li>この時点では、用語のブレは気にしない(first-name, first_name)</li>
</ul></li>
<li>語彙は、データベーススキーマやオブジェクトモデルからはもってこないこと

<ul>
<li>クライアントコードがサーバーサイドに依存してしまうため</li>
</ul></li>
<li>media-type在りきでデータ構造を決定しないこと

<ul>
<li>6. まで我慢する</li>
</ul></li>
<li>IANA登録済みのlink relationと重複させないこと

<ul>
<li>ページネーション

<ul>
<li>first, next, current</li>
<li>next-archive, prev-archive (RFC5005)</li>
</ul></li>
<li>メッセージスレッド

<ul>
<li>replies (RFC4685)</li>
</ul></li>
<li>リソース状態の履歴管理(RFC5829)

<ul>
<li>latest-version</li>
<li>successor-version</li>
<li>predecessor-version</li>
<li>working-copy</li>
<li>working-copy-of</li>
</ul></li>
<li>リソース状態の編集

<ul>
<li>edit</li>
<li>edit-media</li>
</ul></li>
</ul></li>
</ul></li>
<li>APIの状態遷移図を描く

<ul>
<li>一つの状態に一つの表現を割り当てる</li>
<li>一つの状態遷移が一つの矢印となる</li>
<li>httpメソッドはまだ割り当てない</li>
<li>冪等性と安全性は考えておくべき</li>
<li>link relationが発見されるかもしれない

<ul>
<li>構造化された内と外との間のリンク</li>
<li>用語がアプリケーション状態の変化をもたらすのであれば、その用語はリレーション</li>
<li>拡張リンクリレーション

<ul>
<li>http://example.com/maze#exit</li>
<li>profile取り込むことなく使用可能</li>
</ul></li>
</ul></li>
<li>階層構造が変化するかもしれない</li>
<li>状態間は、グループ化されたdescriptor (ValueObject)が行き来する</li>
<li>状態遷移におけるトップレベル表現を設ける

<ul>
<li>ほかの状態へは、ハイパーメディアコントロールを通して</li>
</ul></li>
</ul></li>
<li>semantic descriptorとlink relationが満足するまで、1, 2を繰り返す

<ol>
<li>用語のブレは解消しておくこと</li>
</ol></li>
<li>用語が既知のprofileに存在するのなら、それに置き換える

<ul>
<li>IANAに登録されたリレーション</li>
<li>schema.orgに登録された用語</li>
<li>alps.ioに登録された用語</li>
<li>ドメイン特化フォーマットで使用される用語、などなど</li>
<li>既知の語彙は間違った理解を減らせる</li>
<li>profileの再利用は、書くべきドキュメント量を減らせる</li>
<li>profileの再利用は、ライブラリの再利用を促せる</li>
<li>たいていはprofileを使用せず、media-typeに結びつけてしまっている

<ul>
<li>一つのAPIに対して複数のmedia-typeを独自定義せず、複数のprofileを利用する</li>
</ul></li>
<li>金融、法務関係のprofileは、未整備のため再利用は難しい</li>
</ul></li>
<li>用語と状態遷移図が満足するまで、1 - 3を繰り返す</li>
<li>プロトコルセマンティクスとアプリケーションセマンティクスに適合するmedia-typeを選択する

<ul>
<li>運が良ければ、ドメイン特化フォーマットが見つかるかもしれない</li>
<li>独自定義する場合、標準的な命名規則に従う

<ul>
<li>application/vnd.(org name).(base type)</li>
<li>(例) application/vnd.hoge.maze+xml</li>
</ul></li>
<li>より汎用的な利用を考えているのならIANAにmedia-typeを登録する

<ul>
<li>RFC6838の4, 5節の手順に従う</li>
<li>JSONベースならRFC4627を目を通すべし</li>
<li>XMLベースならRFC3023に目を通すべし</li>
</ul></li>
<li>可能な限り、ハイパーメディアフォーマットを選択する</li>
<li>コレクションパターン

<ul>
<li>Collection+JSON</li>
<li>AtomPub</li>
<li>OData</li>
</ul></li>
<li>有向グラフ構造

<ul>
<li>HTML</li>
<li>HAL</li>
<li>Siren</li>
</ul></li>
<li>読み取り専用API

<ul>
<li>HTML</li>
<li>HAL</li>
<li>JSON-LD</li>
</ul></li>
<li>安全でないメソッドを使用する場合

<ul>
<li>Hydra</li>
<li>Collection+JSON</li>
</ul></li>
</ul></li>
<li>未知の用語に対して、profileを用意する

<ul>
<li>machine-readable フォーマット

<ul>
<li>Alps<br></li>
<li>JSON-LD</li>
<li>XMDPベースのwebページ</li>
</ul></li>
<li>profileでlink relationを定義した場合、IANAのものよりも優先される

<ul>
<li>意図的にやるべきではない</li>
</ul></li>
</ul></li>
<li>状態遷移図を満たすサーバー実装を書く</li>
<li>トップのURLを公開する

<ul>
<li>状態遷移図のゲートウェイをトップURLとする</li>
<li>Profileを配置する

<ul>
<li>自サイト</li>
<li>alps.io</li>
</ul></li>
<li>APIの要約</li>
<li>利用例</li>
<li>サンプルコード</li>
<li>認証手順</li>
<li>Well known URIs Registry (RFC5785)

<ul>
<li>CoRE Link Formatの場合

<ul>
<li>/.well-knoen/coreに問い合わせ</li>
<li>相対URLは、IANAレジストリに登録</li>
<li>ほかリソースのハイパーメディアリンクの一覧を取得できる</li>
</ul></li>
<li>ホストメタデータの取得

<ul>
<li>/.well-known/host-meta.json </li>
<li>または、/.well-known/host-meta</li>
</ul></li>
<li>well known URIは、media-typeに関連付けられる</li>
</ul></li>
</ul></li>
</ol>

<h3>バージョニング</h3>

<ul>
<li>前提

<ul>
<li>第一にAPIのセマンティクスをhuman-readableドキュメントやハイパーメディアドキュメントの外に置くこと
*　変更に強くなる</li>
<li>既存のリソース定義を変更するのではなく、新しいリソースや状態遷移を追加するに留める</li>
</ul></li>
<li>URLに付与

<ul>
<li><li class="v1" href="v1" />のような感じ</li>
<li>media-typeに付与

<ul>
<li>コンテントネゴシエーションとして指定

<ul>
<li>Accept: application/vnd.hoge?version=2

<ul>
<li>media-typeはAPIではないのでやめといた方がいい</li>
</ul></li>
</ul></li>
</ul></li>
<li>profileを使う

<ul>
<li>破壊的変更はhuman-readableに記述</li>
<li>非破壊変更はmachine-readableなハイパーメディアで記述</li>
</ul></li>
<li>リソーススキーマの変更

<ul>
<li>後方互換性を保ちたいなら、異なるURIを持つ新たなリソースを定義する</li>
</ul></li>
</ul></li>
</ul>

<h3>古いAPIの止め方</h3>

<ol>
<li>deplecatedをマークし、公式チャンネルでアナウンスする</li>
<li>しばらくしたら、deplecatedマークしたバージョンはバグ修正しないことをアナウンスする</li>
<li>更に幾つか待って、停止の期限をアナウンスする</li>
<li>停止日が訪れたら、古いAPIのリクエストに対し、410(Gone)を返し、新しいAPIへのリンク先を案内する</li>
</ol>

<h3>既存のAPIをRESTfulにする場合</h3>

<ul>
<li><p>WSDL</p>

<ul>
<li>非RESTful API</li>
<li>サーバー実装と自動生成されるクライアント実装が密結合となる</li>
<li>サーバー実装の変更をクライアントサイドに反映出来ない</li>
</ul></li>
<li><p>既存のJSONベースAPIにハイパーメディアを追加する場合</p>

<ul>
<li>名前(application descriptor) を変更しない</li>
<li>media-typeを変更しない</li>
<li>安全でないリレーションを追加する場合、profileとしてHydraをもつJSON-LDがオススメ</li>
</ul></li>
<li><p>既存のXMLベースのAPIにハイパーメディアを追加する場合</p>

<ul>
<li>XFirn, XLinkをハイパーメディアコントロールとして使用する</li>
</ul></li>
<li><p>たとえわけの分からないレスポンスだったとしても</p>

<ul>
<li>media-typeやrelationがIANAに登録されている</li>
<li>profileドキュメントへのリンクがあれば、なんとか解析はできる

<ul>
<li>profileはmachine-readableに加えて、human-readableな情報があると尚よし</li>
</ul></li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(8)]]></title>
    <link href="http://ritalin.github.io/2015/03-11/restful-web-api-memo-08/"/>
    <updated>2015-03-11T23:26:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-11/restful-web-api-memo-08</id>
    <content type="html"><![CDATA[<h2>Chapter 8. Profiles</h2>

<ul>
<li>アプリケーション特化の拡張機能に対するドキュメント化</li>
<li><p>アプリケーション特化の用語の定義、ドキュメント化</p></li>
<li><p>現在、一般的用いられていることは、大量のhuman-readableなドキュメントを作成すること</p>

<ul>
<li>APIドキュメントについてはRESTful(自己記述性メッセージ)でない</li>
</ul></li>
</ul>

<!-- more -->

<h3>クライアントアプリはいかにしてドキュメントをさがすのか？</h3>

<ul>
<li><p>クライアントがリクエストやレスポンスの意味を推測すべきではない</p>

<ul>
<li>メッセージ自身が、詳細に説明すべき</li>
</ul></li>
<li><p>レスポンスはクライアントがなすべきことを全て含めるべき</p>

<ul>
<li>Content-type

<ul>
<li>リソースの解析方法を示す</li>
</ul></li>
<li>ハイパーメディアコントロール

<ul>
<li>次に発行すべきリクエストをレスポンスに含める</li>
<li>プロトコルセマンティクスを明示する</li>
</ul></li>
<li>ドメイン特化フォーマットの場合

<ul>
<li>リソースに問題領域の状態遷移を含める</li>
<li>アプリケーションセマンティクスを付与する</li>
</ul></li>
</ul></li>
<li><p>多くの場合、プロトコルセマンティクスとアプケーションセマンティクスの両方をフォーマットから読み取ることはできない</p>

<ul>
<li>仕様Profileが欠損している</li>
</ul></li>
</ul>

<h3>Profile</h3>

<ul>
<li><p>media-typeを元にリソースを解析しても得られない仕様(APIドキュメント)</p>

<ul>
<li>たいていHuman-readableな文書</li>
<li>machine-readable profile

<ul>
<li>linkやdescripterで記述されたhuman-readableなドキュメント(Profile)を自動収集できる</li>
</ul></li>
</ul></li>
<li><p>定義(RFC6906)</p>

<ul>
<li>リレーションを使用してProfileとリンク(rel=&quot;profile&quot;)

<ul>
<li>IANAにそのリレーションが登録されている

<ul>
<li>relをサポートするあらゆるハイパーメディアコントロールで利用可能

<ul>
<li>htmlのaタグ</li>
<li>html, Collection+JSON, HALのlinkタグ</li>
<li>RFC5988のLINKヘッダ</li>
</ul></li>
</ul></li>
<li>Ontent-Typeパラメータに追記

<ul>
<li>application/collection+json;profile=&quot;(リンク先URL)&quot;</li>
<li>すべてのmedia-typeで使用できるわけではない(RFC4288)

<ul>
<li>Collection+JSON</li>
<li>JSON-LD</li>
<li>HAL</li>
<li>XHTML</li>
</ul></li>
<li>httpヘッダでprofileリンクを示したいなら、すべてで使えるLINKヘッダを使うべき</li>
</ul></li>
<li>Microdataのitemtype

<ul>
<li>Urlで、リンク先のprofileを指定する</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h3>プロトコルセマンティクスProfile</h3>

<ul>
<li>どのようなHTTPリクエスト発行されるのかについて</li>
<li>フリーフォームな文体で記述</li>
<li>ハイパーメディアコントロールを持たないmedia-type(JSON)に対して用意</li>
<li>HALのようにプロトコルセマンティクスが削ぎ落とされている場合に用意</li>
<li>ハイパーメディアコントロールであれば、リンクリレーションを用いて指定

<ul>
<li>ハイパーメディアコントロールから駆動される状態遷移を記述した文字列

<ul>
<li>GETでアプリケーション状態を遷移</li>
<li>POST, PUT,DELETEでリソース状態を遷移</li>
</ul></li>
</ul></li>
</ul>

<h3>アプリケーションセマンティクスProfile</h3>

<ul>
<li><p>人が用語を理解するようにコンピュータにも理解させること</p></li>
<li><p>利用するデータ構造、パラメータなどの説明文を用意</p></li>
<li><p>用語をセマンティクス記述子に表記</p>

<ul>
<li>microformats

<ul>
<li>class属性</li>
</ul></li>
<li>Siren

<ul>
<li>classエンティティ</li>
</ul></li>
<li>生JSON

<ul>
<li>オブジェクトキー</li>
</ul></li>
<li>生XML

<ul>
<li>タグ名</li>
</ul></li>
</ul></li>
</ul>

<h3>XMDP</h3>

<ul>
<li>machine-readable profileの一種</li>
<li>ほかのmicroformatを説明するためのmicroformat</li>
<li>class属性に特別な意味があることを伝えられる

<ul>
<li>自動的に理解するわけではなく、そんなツールを書く必要がある</li>
</ul></li>
</ul>

<h3>ALPS</h3>

<ul>
<li>XMDP同様、meta-microformst</li>
<li>HTML専用</li>
<li>プロパティ

<ul>
<li>descriptor

<ul>
<li>一つの用語に対して一つ作る</li>
<li>type=&quot;semantic&quot;</li>
<li>子要素のdocタグにhuman-readableな説明を書く</li>
<li>docタグ以外はmachine-readable</li>
<li><descripter href="#fn" />のようにすることで、ハイパーメディアコントロールにすることもできる</li>
</ul></li>
</ul></li>
</ul>

<h3>JSON-LD</h3>

<ul>
<li>元のJSONドキュメントに&quot;context&quot;と呼ばれるmachin-readableドキュメントを組み込む</li>
<li>APIの変更なしに組み込むことが可能</li>
<li>RDFからの派生</li>
<li>アプリケーションセマンティクスを直接説明せず、ハイパーメディアリンクを添えるだけ

<ul>
<li>&quot;n&quot;: <url></li>
<li>&quot;photo_link&quot;: { &quot;@id&quot;: <url>, &quot;@type&quot;: &quot;@id&quot; }</li>
</ul></li>
</ul>

<h3>API自身にドキュメントを埋め込む</h3>

<ul>
<li><p>APIにhuman-readableドキュメントを埋め込めるフォーマットを用いる</p>

<ul>
<li>HTML

<ul>
<li>inputタグのvalue属性</li>
</ul></li>
<li>HAL

<ul>
<li>linkタグのtitle属性</li>
</ul></li>
<li>Siren

<ul>
<li>actionオブジェクトのtitleフィールド</li>
</ul></li>
</ul></li>
<li><p>machine-readableとhuman-readableドキュメントの両方を用意することについて</p>

<ul>
<li>人との対話により動くクライアント、自動化クライアントの両対応のため</li>
<li>両方のセマンティクスギャップをより縮める</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-19/restful-web-api-memo-09/">RESTful Web APIs 読書メモ(9)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(7)]]></title>
    <link href="http://ritalin.github.io/2015/03-09/restful-web-api-memo-07/"/>
    <updated>2015-03-09T21:08:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-09/restful-web-api-memo-07</id>
    <content type="html"><![CDATA[<h2>Chapter 7. Pure hypermedia Design</h2>

<ul>
<li>コレクションパターンは強力であるが、何でもかんでも使えるではない</li>
<li><p>MAZE+xmlのコレクションパターンでの表現（5章）</p>

<ul>
<li>どう見ても迷路ゲームのアプリケーションセマンティクスにマッチしていない</li>
</ul></li>
<li><p>APIの設計方針として、汎用的なハイパーメディアを用いることができる</p></li>
</ul>

<!-- more -->

<h3>HTML</h3>

<ul>
<li>多くのOS標準搭載されたブラウザにレンダリングさせてデバッグできる</li>
<li>XMLやJSONよりも、よりドキュメントとしての構造を強いている</li>
<li>標準化されたハイパーメディアコントロールを有している

<ul>
<li>formタグ(method=&quot;GET&quot; = outbound link

<ul>
<li>inputタグによるURIテンプレート代替</li>
</ul></li>
<li>formタグ(method=&quot;POST&quot; = リソース生成依頼</li>
<li>linkタグ(rel=&quot;stylesheet&quot;) = embedded link</li>
<li>linkタグ(rel=&quot;self&quot;) = outbound link</li>
<li>aタグ = outbound link</li>
<li>imgタグ、scriptタグ = embedded link</li>
<li>特別な問題領域に特化したものではない</li>
</ul></li>
<li><p>解析 / 生成のためのツールが多くある</p></li>
<li><p>データ構造としてのHTML</p>

<ul>
<li>ol = JSON順序リスト</li>
<li>ul = JSON非順序リスト</li>
<li>dl = JSONオブジェクト</li>
<li>table = 二次元配列</li>
<li>div/span = グループ化</li>
</ul></li>
<li><p>汎用属性</p>

<ul>
<li>rel

<ul>
<li>IANAに登録されたリレーションを用いることで、HTMLにアプリケーションセマンティクスを組み込める</li>
</ul></li>
<li>id

<ul>
<li>文書内で一意の識別子</li>
<li>idでアプリケーションセマンティクスをフックするのはオススメではない

<ul>
<li>複数の文書をマージしたい場合に一意性が保証出来ないため</li>
</ul></li>
</ul></li>
<li>class

<ul>
<li>最も柔軟性のある属性</li>
<li>wwwではcssによるフォーマッティングに用いられる</li>
<li>アプリケーションセマンティクスとしては、グループ化のタグとして用いることができる</li>
</ul></li>
</ul></li>
</ul>

<h3>microformat</h3>

<ul>
<li>htmlにアプリケーションセマンティクスを付与する技術</li>
<li>classとrel属性に与える値のみを定義する</li>
<li>html + microformatでドメイン特化なフォーマットを再現できる</li>
<li>hCard

<ul>
<li>グループ化やフィールドのためのclassのみが定義されている</li>
<li>hCard自身はハイパーメディアコントロールではないが、htmlから拝借して、connectednessを実現できる</li>
<li>どのhtmlタグに付けるかは自由</li>
<li>vCard(RFC6350)を元にしている

<ul>
<li>ハイパーメディアコントロールではない</li>
</ul></li>
</ul></li>
</ul>

<h3>Microdata</h3>

<ul>
<li>html5用、microformat改良版</li>
<li>総本山はschema.org</li>
<li>microformstにおけるclassの置き換え</li>
<li>リレーションは定義出来ない</li>
<li>class属性は本来、アプリケーションセマンティクスを体現する場ではない</li>
<li>プロパティ

<ul>
<li>itemprop

<ul>
<li>グループ名、フィールド名の定義</li>
</ul></li>
<li>itemscope

<ul>
<li>Microdataによる表現を開始するタグに付与</li>
</ul></li>
<li>itemtype

<ul>
<li>付与したタグをハイパーメディアコントロールにする</li>
<li>値はURL</li>
</ul></li>
<li>itemid</li>
<li>itemref</li>
</ul></li>
</ul>

<h3>フォームにアプリケーションセマンティクスを加えること</h3>

<ul>
<li><p>リンクリレーションは、リソース間の関連を記述するもの</p>

<ul>
<li>自身と同じURLに異なるリンクリレーションのリンクを貼る =&gt; リソース状態が変更されることを意味する</li>
<li>リンクはGETリクエストの発行となるため、HTTPメソッドの制約に反する</li>
</ul></li>
<li><p>HTMLフォームなら、POSTリクエストを発行できる</p>

<ul>
<li>リソース状態を変更することは制約に反しない</li>
<li>inputタグのclass属性にアプリケーションセマンティクスとなる用語を与える</li>
<li>アクションURLを組み立てるためのテンプレートは不要

<ul>
<li>formタグがアクションURLを持つため</li>
</ul></li>
<li>sublitタイプのinputタグを置いて初めて、状態遷移が可能となる

<ul>
<li>遷移させたくなければ、sublitを置く必要はない</li>
</ul></li>
</ul></li>
<li><p>リソース指向アプローチ</p>

<ul>
<li>リソースを識別し、そこにハイパーメディアを試みる作り</li>
<li>まずリソースを識別することに重きを置いている</li>
</ul></li>
<li><p>ハイパーメディア設計</p>

<ul>
<li>リソースを識別することよりも状態遷移を識別することの方が重要</li>
</ul></li>
</ul>

<h3>HTMLの限界</h3>

<ul>
<li>本来のHTMLは、ハイパーメディアフォーマットなどではなく、human-readableに特化した標準</li>
<li>全てのhttpプロトコルを実現できない

<ul>
<li>PUT, DELETEはJavascriptの手助けが必要</li>
</ul></li>
<li>formで構成できるリクエストは、application/x-www-form-urlencodedか、multipart/form-dataのいずれか</li>
<li>文字列と数字を区別しない

<ul>
<li>そのアプリケーションセマンティクスはhtmlの外で定義するしかない</li>
</ul></li>
<li>日付表現を定義していない

<ul>
<li>vCardのbdayはISO8601として個別に定義</li>
</ul></li>
</ul>

<h3>html5</h3>

<ul>
<li>timeタグ

<ul>
<li>特定のフォーマットでdate型やtimestamp型を表現</li>
</ul></li>
<li>meterタグ

<ul>
<li>特定の範囲内の測定値を表現</li>
</ul></li>
<li>audioタグ</li>
<li>videoタグ</li>
<li>sourceタグ</li>
<li>embedタグ</li>
<li>inputタグのvalidation

<ul>
<li>値としてdate, number, urlを表現</li>
<li>required属性で必須入力</li>
<li>クライアントサイドバリデーション</li>
</ul></li>
<li>formタグ

<ul>
<li>texp/plainメディアタイプのサポート</li>
</ul></li>
<li>Microdata

<ul>
<li>classs属性への意味づけ</li>
</ul></li>
<li>PUT, DELETEは引き続き未サポート</li>
</ul>

<h3>Hypermedia Application Language (HAL)</h3>

<ul>
<li>media-type

<ul>
<li>application/hal+xml</li>
<li>application/hal+json</li>
</ul></li>
<li>要素としてresourceとlinkタグのみを定義されている</li>
<li>resourceタグ

<ul>
<li>httpリソースの表現</li>
</ul></li>
<li>link

<ul>
<li>これ一つであらゆるハイパーメディアを扱える

<ul>
<li>GET, POST, PUT, DELETE, UNLINK</li>
<li>プロトコルセマンティクスを指定するすべはない</li>
<li>リレーションの意味を明示的にドキュメントとして残すしかない</li>
</ul></li>
</ul></li>
</ul>

<h3>Siren</h3>

<ul>
<li>JSONベースのハイパーメディアフォーマット</li>
<li>HTMLとCollection+JSONの合いの子のような立ち位置</li>
<li>entities

<ul>
<li>データをグループ化</li>
<li>htmlのdivタグ相当</li>
<li>URLを付与することでサブリソースとして振舞わせられる</li>
<li>links

<ul>
<li>別のリソースへのリンク先を記述</li>
</ul></li>
</ul></li>
</ul>

<h3>Semantics Challenge</h3>

<ul>
<li>httpプロトコルセマンティクス

<ul>
<li>リソースにGET, POSTなどのリクエストメソッドを割り当てる</li>
</ul></li>
<li>ハイパーメディア

<ul>
<li>サーバーで次に行わせたいリクエストを伝える仕組み</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>アプリケーション状態やリソース状態をハイパーメディアで制御すること</li>
</ul></li>
<li>ドメイン特化フォーマット

<ul>
<li>例: Maze+XML</li>
<li>プロトコルセマンティクスを定義</li>
<li>アプリケーションセマンティクスも定義</li>
<li>稀な存在</li>
</ul></li>
<li>標準フォーマット

<ul>
<li>Collection+JSON, AtomPubなど</li>
<li>プロトコルセマンティクス詳細に定義している

<ul>
<li>item-typeリソース = PUTに応答</li>
</ul></li>
<li>アプリケーションセマンティクスは未定義</li>
</ul></li>
<li>microformat

<ul>
<li>アプリケーションセマンティクスを定義</li>
<li>プロトコルセマンティクスは未定義</li>
</ul></li>
<li>HTML, HAL, Siren

<ul>
<li>プロトコルセマンティクスを定義</li>
<li>アプリケーションセマンティクスも定義</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-11/restful-web-api-memo-08/">RESTful Web APIs 読書メモ(8)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(6)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-06/"/>
    <updated>2015-03-08T22:47:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-06</id>
    <content type="html"><![CDATA[<h2>Chapter 6. The Collection Pattern</h2>

<ul>
<li>コレクションもまたリソース

<ul>
<li>  コレクションに含まれるリソースは&quot;item&quot;や&quot;entry&quot;、&quot;member&quot;と呼ばれる</li>
</ul></li>
<li>  Pagenation

<ul>
<li>  大量のコレクションメンバーを持つ場合、全てを一度に返すことは通常しない</li>
<li>  最初の一部だけをコレクションとして返し、残りはrel=&quot;next&quot;を付与したリンクだけを提供する

<ul>
<li>  nextはIANAで登録されている</li>
<li>  ほかにprev, first, lastもIANAで定義されている</li>
</ul></li>
<li>  Collection+JSONはリレーションを明示的にサポートしてはいない

<ul>
<li>  必要ならリレーションを組み込めばいい</li>
</ul></li>
</ul></li>
</ul>

<!-- more -->

<h3>Collection+JSON</h3>

<ul>
<li>問題領域とは独立した汎用フォーマット</li>
<li>手軽にREST制約を組み込める</li>
<li>httpを介して取得するリソースのためのプロトコルセマンティクス</li>
<li>プロパティ

<ul>
<li>href

<ul>
<li>コレクション自身へのリンク</li>
</ul></li>
<li>items

<ul>
<li>コレクションの要素</li>
<li>アプリケーション特化データの集合

<ul>
<li>href

<ul>
<li>要素へのリンク</li>
<li>GETリクエストで単独のリソースとして取得できる</li>
<li>PUTやDELETEで変更、削除</li>
</ul></li>
<li>links

<ul>
<li>要素に関連するほかのリソースへのリンク</li>
<li>例えば、本リソースに対する著者、出版社等</li>
<li>render=&quot;link&quot;

<ul>
<li></li>
</ul></li>
<li>render=&quot;image&quot;

<ul>
<li></li>
</ul></li>
</ul></li>
<li>data

<ul>
<li>要素を構成する内容</li>
<li>アプリケーションセマンティクスの要</li>
<li>&quot;name&quot;と&quot;value&quot;から成るJSONオブジェクトの集合</li>
<li>各ペアには備考として&quot;prompt&quot;をもたせられる</li>
</ul></li>
</ul></li>
</ul></li>
<li>links

<ul>
<li>コレクションに関連するほかの要素</li>
</ul></li>
<li>queries

<ul>
<li>コレクションを検索するためのテンプレート</li>
</ul></li>
<li>templates

<ul>
<li>コレクションに新しい要素を加えるためのテンプレート</li>
</ul></li>
<li>error

<ul>
<li>エラーメッセージ</li>
</ul></li>
</ul></li>
</ul>

<h3>AtomPub</h3>

<ul>
<li>Atomフォーマット

<ul>
<li>RSSに代わり、ニュースを同報する仕組みとしてRFC4287で標準化</li>
<li>ニュース記事を一つ以上のカテゴリに分類できる</li>
</ul></li>
<li>AtomPubはニュースを編集 / 発行(CRUD)などを行うためのAtomフォーマットを使ったワークフロー(RFC5023)</li>
<li>media-typeはapplication/atom+xml</li>
<li>新しいエントリーはURIにPOSTすることで行う</li>
<li>リンクにrel=&quot;edit&quot;を付与することで編集可能なエントリーであることを示す(PUTサポート) </li>
<li>Collection+JSONと同じコンセプトをもつ

<ul>
<li>コレクション要素は&quot;item&quot; -&gt; &quot;feed&quot;</li>
<li>Collection+JSONは汎用フォーマットなので、itemに特別なアプリケーションセマンティクスわ定義していない</li>
<li>AtomPubはニュース配信プロトコルなので、エントリーはニュース記事</li>
</ul></li>
<li>コレクションパターンのプラグイン基盤としても用いられる

<ul>
<li>Atom Threading Extension

<ul>
<li>RFC4685</li>
<li>メールスレッド表現</li>
<li>rel=&quot;replies&quot;</li>
</ul></li>
<li>Atom deleted entry element

<ul>
<li>RFC6721</li>
<li>エントリーを削除するのではなく墓石を置削除扱いとする</li>
</ul></li>
<li>Feed Paging and Archiving

<ul>
<li>RFC5005</li>
<li>アーカイブフィードコンセプトを定義</li>
<li>複数のリソースをまたがるきょだなフィードをPagingする方法</li>
<li>rel属性として、next-archive, prev-archive, currentを使う</li>
</ul></li>
<li>OpenSearch

<ul>
<li>xmlベースの検索プロトコル標準</li>
<li>rel=&quot;search&quot;</li>
<li>Collection+JSONにおけるqueriesプロパティど同等のもの</li>
</ul></li>
<li>PubSubHubbub

<ul>
<li>Atomフィードが更新されたときに通知を行うためのプロトコル</li>
<li>rel=&quot;hub&quot;</li>
</ul></li>
<li>これらのリレーションは全てIANAに登録されている

<ul>
<li>何の説明もなく使用できる</li>
</ul></li>
</ul></li>
<li>プロパティ

<ul>
<li>feed

<ul>
<li>ID

<ul>
<li>一意的にニュースを識別するためのもの</li>
</ul></li>
<li>title

<ul>
<li>見出し</li>
</ul></li>
<li>subtitle</li>
<li>author</li>
<li>date, time

<ul>
<li>発行日時 / 最終更新日時</li>
</ul></li>
</ul></li>
</ul></li>
<li>アプリケーションセマンティクスのためにプロパティを拡張することが認められている

<ul>
<li>Googleでは、マップ上のシンボル、カレンダー、スプレッドシートのセル、ビデオ用に付加的な表現を拡張している(GData)</li>
</ul></li>
</ul>

<h3>OData</h3>

<ul>
<li>AtomPubベース</li>
<li>MSが協力しているのでVisual studioから使いやすい</li>
</ul>

<h3>Hydra</h3>

<ul>
<li>あまり表舞台では見かけない</li>
</ul>

<h3>Semantics Challenge</h3>

<ul>
<li><p>ドメイン特化なフォーマットの場合(MAZE+xml)</p>

<ul>
<li>カスタムタイプ、リンクリレーションがセマンティクスギャップを埋める

<ul>
<li>カスタム定義したハイパーメディアタイプ</li>
<li>問題空間のために定義されたリンクリレーション</li>
</ul></li>
</ul></li>
<li><p>コレクションパターンは2種類のリソースタイプに大別される</p>

<ul>
<li>item-type

<ul>
<li>GET, PUT, DELETE</li>
<li>内容+ item自身へのリンクをもつ</li>
</ul></li>
<li>collection-type

<ul>
<li>GET, POST(as append)</li>
<li>item-typeリソースをメンバーとしてもつ</li>
</ul></li>
</ul></li>
<li><p>collection-typeはリンクリレーションによるナビゲーションでアプリケーションセマンティクスを定義する</p>

<ul>
<li>first, next, search</li>
</ul></li>
<li><p>item-type</p>

<ul>
<li>一般的に定義されたアプリケーションセマンティクスはない</li>
<li>Collection+JSON

<ul>
<li>item-typeリソースの意味は、prompt要素にhuman-readableな説明として記述される</li>
</ul></li>
</ul></li>
<li><p>同じドメインでも、APIが異なれば、アプリケーションセマンティクスは異なる</p>

<ul>
<li>text or content</li>
<li>post ot blogPost</li>
<li>etc,&#8230;</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-09/restful-web-api-memo-07/">RESTful Web APIs 読書メモ(7)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ESTful Web APIs 読書メモ(5)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-05/"/>
    <updated>2015-03-08T22:19:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-05</id>
    <content type="html"><![CDATA[<h2>Chapter.5 Domain-Specific Designs</h2>

<ul>
<li> ドメイン特化設計

<ul>
<li>ドメイン特化のmedia-typeではなく、一般的なmedia-typeにアプリケーションセマンティクスを加える方が良い

<ul>
<li>Aplication/vnd.xxx.Maze+XML</li>
</ul></li>
<li>API設計する際に平均的な開発者が最初に選択する</li>
<li>RFC5988

<ul>
<li>リンク間の関係を定義</li>
</ul></li>
</ul></li>
</ul>

<!-- more -->

<ul>
<li>Maze+XMLでスタート地点を得るためにAPI callメタファを使うと

<ul>
<li>迷路一覧をGET

<ul>
<li>rel=&quot;maze&quot;で対象の迷路が判明</li>
</ul></li>
<li>対象の迷路をGET

<ul>
<li>rel=&quot;start&quot;でエントランスが判明</li>
</ul></li>
<li>迷路のエントランスセルをGET

<ul>
<li>relで各方角のセルが判明</li>
</ul></li>
</ul></li>
<li>API callメタファ

<ul>
<li>サーバーの実装の詳細が露出しがちになる</li>
<li>サーバーとクライアントが密結合となる</li>
<li>APIをおいそれと修正出来なくなる</li>
</ul></li>
<li><p>ドメイン特化API</p>

<ul>
<li>作成者

<ul>
<li>human-readableな仕様を書く</li>
<li>その仕様にmedia-typeを関連付けIANAに登録する</li>
</ul></li>
<li>利用者

<ul>
<li>IANAレジストリで未知のmedia-typeを探す</li>
<li>登録された仕様を読み、利用方法を学ぶ</li>
</ul></li>
</ul></li>
<li><p>クライアント</p>

<ul>
<li>human-driven</li>
<li>clawler

<ul>
<li>全てのハイパーメディアをたどる</li>
</ul></li>
<li>script

<ul>
<li>最初に遭遇したハイパーメディアのみをたどる</li>
</ul></li>
<li>monitor

<ul>
<li>ハイパーメディアを列挙する</li>
</ul></li>
<li>agent

<ul>
<li>アルゴリズムを基づき、ハイパーメディアを取捨選択する</li>
</ul></li>
</ul></li>
<li><p>自動化されたクライアントは、ハイパーメディアAPIのメリットを最も享受できる</p>

<ul>
<li>ゴールが見えている</li>
<li>ゴールへのみちが示されている</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-06/">RESTful Web APIs 読書メモ(6)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(4)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-04/"/>
    <updated>2015-03-08T22:15:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-04</id>
    <content type="html"><![CDATA[<h2>Hypermedia</h2>

<!-- more -->

<ul>
<li><p>ハイパーメディア</p>

<ul>
<li>リソースを互いに結びつけ合わせること</li>
<li>将来発行することになるリクエストをサーバーがクライアントに伝える方法</li>
<li>あたかもメニューのようなもの</li>
</ul></li>
<li><p>ハイパーメディアとしてのHTML</p>

<ul>
<li>リンクを選択すること = リンク先のリソースに&quot;visit&quot;すること

<ul>
<li>表示されたリソースを新しいリソースで置き換えること</li>
</ul></li>
<li>aタグ

<ul>
<li>あるURLに対して、リンクを選択した場合のみ発行されるGETリクエストを発行するもの</li>
<li>imgタグ

<ul>
<li>あるURLに対して、バックグラウンドで自動的にGETリクエストを発行するもの</li>
</ul></li>
<li>formタグ(method=POST)

<ul>
<li>あるURLに対して、submitした場合に、クライアントが生成したエンティティボディをもつPOSTリクエストを発行するもの</li>
</ul></li>
<li>formタグ(method=GET)

<ul>
<li>submitした場合に、クライアントが生成したクエリボディをもつURLにGETリクてを発行するもの</li>
<li>human-readableなURLは作られない</li>
<li>RFC6570, URI Templateを使うと、human-readableにできる</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>URIとURLの違い</p>

<ul>
<li>URL

<ul>
<li>リソースを見分けるための短い文字列</li>
<li>URLはURIの一種</li>
<li>RFC3986で標準化</li>
<li>何らかの表現と関連づいてる</li>
</ul></li>
<li>URI

<ul>
<li>リソースを見分けるための短い文字列</li>
<li>RFC3986で標準化</li>
<li>表現をもつ保障はない</li>
<li>URNもURIの一種</li>
</ul></li>
<li>URLなしでは、リソースを表現として得られない -&gt; REST制約を満たせない</li>
<li>URNでリンクをつくってもハイパーメディア制約を満たせない</li>
<li>URLであれば、REST制約を満たせる</li>
</ul></li>
<li><p>HTTPリクエストやレスポンスのLINKヘッダ(RFC5988)</p>

<ul>
<li>画像やただのplain textをハイパーメディアを付与する

<ul>
<li>画像であればスライドショー</li>
<li>テキストであれば、本文の続き</li>
</ul></li>
</ul></li>
<li><p>ハイパーメディアの仕事</p>

<ul>
<li>クライアントにHTTPリクエストの構築方法を伝達

<ul>
<li>aタグ: メソッド(暗黙的)とURL(明示的) を提示している</li>
<li>formタグ: メソッド、URL、送信本文を提示

<ul>
<li>encType属性を付与することでContent-Typeヘッダを提示できる</li>
</ul></li>
<li>URI Template: URLを提示</li>
</ul></li>
<li>HTTPレスポンスについての約束事をとりつける

<ul>
<li>imgタグ:

<ul>
<li>aタグ同様GETリクエストとなることを提示</li>
<li>サーバーがレスポンスとして画像を返すことを約束づけている</li>
</ul></li>
<li>AtomPubのlinkタグ

<ul>
<li>rel=&quot;edit&quot;の付与で、GETに加えPUT, DELETEのサポートを約束づけている</li>
<li>AtomPub Member Entity表現がレスポンスとして返されることを約束づけている</li>
</ul></li>
</ul></li>
<li>ワークフロー制御の提案

<ul>
<li>リソース間の関係を提示

<ul>
<li>aタグ

<ul>
<li>現在のページから指定されたURLのページに移動する</li>
<li>out-bound リンク(アプリケーション状態を変化させる) </li>
</ul></li>
<li>imgタグ

<ul>
<li>embeddedリンク(アプリケーション状態を変化させない) </li>
</ul></li>
<li>scriptタグ

<ul>
<li>表現をダウンロードし、実行</li>
</ul></li>
<li>link rel=&quot;stylesheet&quot;

<ul>
<li>スタイルシートを適用する</li>
</ul></li>
<li>framesetタグ

<ul>
<li>別のhtmlドキュメントを埋め込む</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>ハイパーメディアの偽物にご用心</p>

<ul>
<li>JSONはハイパーメディアをサポートしていない。</li>
<li>URLに見えても、仕様上、所詮ただの文字列</li>
<li>web APIのレスポンスとして生JSONを使用することはREST制約を満たせない</li>
<li>web APIのレスポンスにはハイパーメディアをサポートするmedia typeを使うべき</li>
</ul></li>
<li><p>imgタグとscriptタグもGETでリソース表現を取得する点でプロトコルセマンティクスや違いはない</p></li>
<li><p>各々のタグから導かれるアプリケーションセマンティクスに従って処理を行う</p></li>
</ul>

<h3>Semantics Challenge</h3>

<ul>
<li>Webブラウザは、人との対話を通してリンク先を決定する</li>
<li><p>いかにすれば、人の介在なしにこの振る舞いを実現できるのか？</p></li>
<li><p>HTMLのimgタグも、scriptタグも、HTTPの観点では違いはない</p>

<ul>
<li>同一のプロトコルセマンティクスを持つ</li>
<li>アプリケーションセマンティクスは異なるが・・・</li>
</ul></li>
<li><p>ドメイン特化アプリの場合、ハイパーメディアコントロールがセマンティクスギャップを埋める可能性を持つ</p>

<ul>
<li>画像収集アプリであれば、imgタグだけを踏み、scriptタグを無視する</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-05/">RESTful Web APIs 読書メモ(5)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(3)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-03/"/>
    <updated>2015-03-08T22:11:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-03</id>
    <content type="html"><![CDATA[<h2>Chapter 3. Resources and Representations</h2>

<!-- more -->

<ul>
<li>RESTは、プロトコルでもファイルフォーマットでもフレームワークでもない。</li>
<li>RESTは設計制約のセット

<ul>
<li>ステートレス</li>
<li>HATEOAS</li>
<li>などなど</li>
</ul></li>
<li><p>HTTP, URI, HTMLを理解することは、REST制約を理解するための鍵となる</p>

<ul>
<li> HTTP, URI, HTMLの根底には、リソース、表現という概念がひそんでいる</li>
<li>Clientにとって、Resourceがなにであるかは重要ではない。ClientはURLと結果の表現だけを見ているから</li>
<li>表現とは、有益な形にリソースを加工したドキュメントであり、リソースの現在の状態をクライアントで読み取れるようにしたもの</li>
</ul></li>
</ul>

<p>*GET
    * 表現の問い合わせ
 * POST, PUT, PATCH
    * 表現の提案</p>

<ul>
<li><p>リソースは一つ以上の表現をもつ</p>

<ul>
<li>言語(en, ja,&#8230;)</li>
<li>フォーマット(JSON, XML,&#8230;)</li>
<li>要約と全文</li>
</ul></li>
<li><p>クライアントからは、</p>

<ul>
<li>content negotiation</li>
<li>一つのURLに複数のURI</li>
</ul></li>
</ul>

<h3>プロトコルセマンティクス</h3>

<ul>
<li><p>リクエストメソッド</p>

<ul>
<li>GET

<ul>
<li>リソース表現を取得</li>
<li> 安全でかつ冪等</li>
<li>リソースの状態変更を期待する場面では使うべきでない</li>
<li>よく使われるレスポンスコードは200(OK) or 301(Moved permanently)</li>
<li>リソースがない場合、404(Not found)</li>
<li>リソースが削除(DELETE)されていた場合、410(Gone)</li>
</ul></li>
<li>DELETE

<ul>
<li>リソースを破棄</li>
<li>安全ではないが冪等</li>
<li>よく使われるレスポンスコードは204(No content), 200(OK), 202(Accepted: 後で削除)</li>
</ul></li>
<li>POST(to append)

<ul>
<li>指定された表現でリソースを新規作成</li>
<li>追記の場合のレスポンスコードは201(Created)</li>
<li>201は作成されたリソースのURIを示すLocationヘッダをもつ</li>
<li>作成はするがまだ完了していない場合、202(Accepted)が返される</li>
<li>安全でもなく冪等でもない</li>
</ul></li>
<li>POST(overload)

<ul>
<li>PUT, DELETEの代わりに投げつける</li>
</ul></li>
<li>PUT

<ul>
<li>リソースを置き換える</li>
<li>GETで取得し、修正してPUTで投げる</li>
<li>リクエスト内容に不備があれば、サーバーは拒否する自由がある</li>
<li>返されるステータスコードは、200(OK), 204(No content)</li>
<li>冪等である</li>
<li>既知のURLに新しいリソースを作成するためにも用いられる</li>
<li>新規リソースを作成する場合でさえ冪等</li>
</ul></li>
<li>HEAD

<ul>
<li>リソースのヘッダレスポンスのみ返す</li>
</ul></li>
<li>OPTIONS

<ul>
<li>利用できるhttpメソッドの列挙</li>
</ul></li>
<li>CONNECT, TRACE

<ul>
<li>プロキシのためのもの</li>
</ul></li>
</ul></li>
<li><p>RFC-5789</p>

<ul>
<li>PATCH

<ul>
<li>指定された表現に基づいてリソースの一部を修正する</li>
<li>PUTとは異なり微調整が可能</li>
<li>リクエストも変更対象の差分だけを送ることが可能</li>
<li>変更後のリソースをクライアントに戻す場合、200(OK)を返す</li>
<li>成功を伝えるだけであれば、304(No Content)を返す</li>
</ul></li>
</ul></li>
<li><p>標準候補だった(RFC2068で入り、2616で破棄)</p>

<ul>
<li>LINK

<ul>
<li>別のリソースとリンクを張る</li>
<li>安全ではないが冪等</li>
<li>URLはLINKヘッダで指定</li>
</ul></li>
<li>UNLINK

<ul>
<li>別のリソースとのリンクを破棄する</li>
<li> 安全ではないが冪等</li>
<li>URLはLINKヘッダで指定</li>
</ul></li>
</ul></li>
<li><p>WebDAV(RFC4918)</p>

<ul>
<li>COPY, MOVE, LOCKなど7つのメソッドを追加</li>
</ul></li>
<li><p>RESTful system</p>

<ul>
<li>独立したコンポーネント(サーバー、クライアント、キャッシュ、プロキシ)で構成されている</li>
<li>HTTPのプロトコルセマンティクスの大半はHTTPメソッドとして定義されている</li>
<li>APIをhtmlで記述する場合、メソッドはGET, POSTに制限される</li>
<li>ファイルシステムGUIアプリなら、HTTP+WebDAVのメソッドが使われるだろう</li>
<li>キャッシュやプロキシならPATCHメソッドの使用が考えられる</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-04/">RESTful Web APIs 読書メモ(4)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(2)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-02/"/>
    <updated>2015-03-08T19:53:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-02</id>
    <content type="html"><![CDATA[<h2>Chapter 2. A Simple API</h2>

<!-- more -->

<h3>GETリクエスト</h3>

<ul>
<li>リソース状態の変更は意図しない

<ul>
<li>アクセスカウンタやログ保存のような付随した事象の変更はOK</li>
</ul></li>
<li><p>安全なメソッド</p></li>
<li><p>過去にGETリクエストで、リソース状態の変更がしばしば行われていたが、これは間違った設計</p></li>
</ul>

<h3>レスポンス</h3>

<ul>
<li>status code

<ul>
<li>リクエストがどう処理されたかという結果をクライアントに知らせる</li>
</ul></li>
<li>entity-body

<ul>
<li>ドキュメント本体</li>
</ul></li>
<li>レスポンスヘッダ

<ul>
<li>entity-bodyを記述するためのKey-Valueペア</li>
<li>status codeの後、entity-bodyの前に送られる</li>
<li>content-type

<ul>
<li>どんなentity-bodyが返されたかクライアントに知らせる</li>
<li>media-type</li>
</ul></li>
</ul></li>
</ul>

<h4>JSON</h4>

<ul>
<li>APIレスポンスの表現として用いられるフォーマット(RFC4627)</li>
</ul>

<h4>Collection+JSON</h4>

<ul>
<li>Publishing APIの目的で用いることができるフォーマット</li>
<li><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-06/">6章参照</a></li>
<li>利用可能なリソースの一覧を発行するための標準</li>
<li>collection, items, valueのそれぞれにhrefプロパティをもつ</li>
<li>リスト、明細、フォームテンプレート、検索結果のいづれでも同じフォーマット</li>
<li><p>hrefと名付けられたとき、その内容はかならずURI</p></li>
<li><p>Collection+JSONを使った、itemの追加</p>

<ul>
<li>template構造に基づいて、内容を埋める

<ul>
<li>content-type: application/vnd. collection+jsonでPOSTリクエストを発行する</li>
<li>成功したら、ステータスコード201を返す</li>
<li>また、レスポンスには新しいリソースのURIを含めておく</li>
<li>新しく作成されたリソースもまたGETリクエストで取得すると、それもまた、Collection+JSON</li>
</ul></li>
</ul></li>
</ul>

<h3>POSTリクエスト</h3>

<p>（なんかまとめづらい内容なので省略）</p>

<h3>アプリケーションセマンティクスがセマンティクスギャップを作ること</h3>

<ul>
<li><p>アプリケーションセマンティクス</p>

<ul>
<li>アプリケーション特有の構造</li>
<li>media-typeのフォーマットとしては規定されていない構造</li>
</ul></li>
<li><p>標準化された、もしくは互いに合意されたアプリケーションセマンティクスであれば、セマンティクスギャップ消失する</p></li>
<li><p>あえてセマンティクスギャップを広げることで、APIに差別化をもたらすことができるかもしれない</p></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-03/">RESTful Web APIs 読書メモ(3)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(1)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-01/"/>
    <updated>2015-03-08T17:45:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-01</id>
    <content type="html"><![CDATA[<h2>Chapter 1. Surfing the Web</h2>

<ul>
<li>Webは分散コンピューティングの力を秘めている</li>
</ul>

<!-- more -->

<h3>Webを形作るテクノロジ</h3>

<ul>
<li>URL

<ul>
<li>リソースの識別子</li>
</ul></li>
<li>HTTPプロトコル

<ul>
<li>URLにHTTPリクエストを投げ、リソースを表現として取得する</li>
</ul></li>
<li>HTMLフォーマット</li>
</ul>

<h3>Addressability</h3>

<p>すべてのリソースが自身を時期別するURLを持つこと</p>

<h3>自己記述性メッセージ</h3>

<p>Webはリンクを介した対話を提供する</p>

<h3>標準化されたメソッド</h3>

<ul>
<li>HTTPメソッド(RFC2616)

<ul>
<li>GET

<ul>
<li>リソースの表現を交換すること

<ul>
<li>表現 = リソース状態を時にはtextで、時には画像として、求められた形で返すこと</li>
</ul></li>
</ul></li>
<li>HEAD</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
</ul></li>
</ul>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-03/">3章参照</a></p>

<h3>Application State</h3>

<p>クライアントサイドの状態</p>

<ul>
<li><p>アプリケーション状態はユーザーからのインタラクション、またはサーバーからの応答で更新されて</p></li>
<li><p>例</p>

<ul>
<li>マイクロブログに投稿する内容</li>
<li>選択したチェックボックス</li>
<li>カートの中身</li>
</ul></li>
</ul>

<h3>Resource state</h3>

<p>サーバーサイドの状態</p>

<ul>
<li><p>クライアントは直接リソース状態を制御できない</p>

<ul>
<li>クライアントに保持されるアプリケーション状態と、サーバーに保存されたリソース状態を交換することで間接的に制御</li>
</ul></li>
<li><p>例</p>

<ul>
<li>リソースに記録された内容</li>
<li>投稿された内容</li>
<li>ある日時の天気</li>
</ul></li>
</ul>

<h3>Connectedness</h3>

<p>wwwは連結性(connectedness)の原理で動いている(HATEOASと呼ばれる)</p>

<p>HATEOAS = hypermedia as the engine of application state</p>

<p>hypermedia = アプリケーション状態のエンジン = linkをクリックしたり、formから提出すること</p>

<h3>REST APIの問題点</h3>

<ul>
<li>しばしば別の、Human-readableドキュメントでAPIの利用方法が説明される

<ul>
<li>自己記述性メッセージとConnectednessの原則を破壊する</li>
</ul></li>
<li>サイトが変更されても、古いクライアントアプリでも動くよう後方互換性をもたせるべき</li>
</ul>

<h3>Semantic Challenge</h3>

<ul>
<li>Web APIの最大の挑戦

<ul>
<li>ドキュメント構造の理解と、その意味を理解することの間のセマンティクスギャップを埋めること</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-02/">RESTful Web APIs 読書メモ(2)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cornice Tutorial (3)]]></title>
    <link href="http://ritalin.github.io/2013/07-04/cornice-tutorial-03/"/>
    <updated>2013-07-04T01:00:00+09:00</updated>
    <id>http://ritalin.github.io/2013/07-04/cornice-tutorial-03</id>
    <content type="html"><![CDATA[<h2>はじめに</h2>

<p>公式サイトの<a href="http://cornice.readthedocs.org/en/latest/tutorial.html">チュートリアル</a>の写経、第三回。
ユーザー管理サービスの実装において、Validatorの話がでてくるので、内容を抑えつつ一覧、追加、削除の実装を進めていきたいと思います。</p>

<!-- more -->

<h2>サービスの処理フロー</h2>

<p>サービスの各処理はその前後に処理を挟むことができます。前方に挟む方をValidator、後方をFilterと呼びます。
処理の指定はサービス定義、またはデコレータをHTTPメソッドのアノテーションとして使用し、その引数にその関数を渡すことで行います。</p>

<p>即ち処理フローは、</p>

<ul>
<li>Validator（オプション）</li>
<li>本処理（必須）</li>
<li>Filter（オプション）</li>
</ul>

<p>となります。</p>

<h2>Validator</h2>

<p>Validatorとは、サービス実装コードの本処理の全面で実行されるプリプロセスであり、CorniceにおけるValidatorの責務は</p>

<ul>
<li>リクエスト入力値のチェック</li>
<li>リクエスト入力値の変換（例えば任意のオブジェクトへ等）</li>
</ul>

<p>とされています。
ここで入力値として、クエリパラメータやPOSTパラメータだけでなく、HTTPヘッダも対象とすることができます。</p>

<p>Validatorの指定はサービスの定義またはメソッドアノテーションの引数として以下のように行います。</p>

<blockquote>
<p>(サービス定義)</p>

<p>service = Service(&#8230;, validators=&lt;関数&gt;, &#8230;)</p>

<p>（メソッドアノテーション）</p>

<p>@service.Get(&#8230;, validators=&lt;関数&gt;, &#8230;)</p>
</blockquote>

<p>Validator関数のインターフェースは、Requestオブジェクトを受け取り、何も返さない手続きです。</p>

<p>入力値が妥当な場合、Request#validatedディクショナリに、エラーの場合、Request#errorsディクショナリにそれぞれ値を格納します。
実例は後の写経の節で。</p>

<p>Requestは基盤として使用しているPyramidのものをベースに、Validate結果格納用のディクショナリが付与されたものとなっています。
Requestオブジェクトを介して受け取れる値については<a href="http://docs.pylonsproject.jp/projects/pyramid-doc-ja/en/latest/api/request.html#pyramid.request.Request">APIリファレンス</a>を確認してください。</p>

<p>Request#errorsディクショナリに１つでも値が格納された場合、本処理は実行されず、組み込みのエラーハンドラが実行されます。</p>

<h2>エラーハンドラ</h2>

<p>組み込みのエラーハンドラは、正常処理の時と同様に、simpleJsonを使用します。</p>

<p>このエラーハンドラもまたサービスの定義またはメソッドアノテーションの引数として指定することができます。</p>

<blockquote>
<p>(サービス定義)</p>

<p>service = Service(&#8230;, error_handler=&lt;関数&gt;, &#8230;)</p>

<p>（メソッドアノテーション）</p>

<p>@service.Get(&#8230;, error_handler=&lt;関数&gt;, &#8230;)</p>
</blockquote>

<p>エラーハンドラ関数のインターフェースは、エラー内容を引数に取り、<a href="http://pylons-webframework.readthedocs.org/en/v0.9.7/thirdparty/webob.html#module-webob.exc">webob.exc.HTTPError</a>の派生クラスを返す関数です。</p>

<blockquote>
<p>error<em>handler</em>func(errors): Response</p>
</blockquote>

<p>エラー内容として、Request#errorsディクショナリが渡されます。</p>

<p>どのように実装するかは、corniceの<code>util.py</code>に記述されている、<code>json_error</code>関数を眺めてみるのがよいかと思います。</p>

<h2>Filter</h2>

<p>Filterは、サービス実装コードの本処理から返されるレスポンスを加工する目的のために使用されます。</p>

<p>Filterの指定はValidator同様に、サービス定義またはメソッドアノテーションの引数として以下のように指定します。</p>

<blockquote>
<p>(サービス定義)</p>

<p>service = Service(&#8230;, filters=&lt;関数&gt;, &#8230;)</p>

<p>（メソッドアノテーション）</p>

<p>@service.Get(&#8230;, filters=&lt;関数&gt;, &#8230;)</p>
</blockquote>

<p>Filterのインターフェースは、レスポンスデータを受け取り、加工されたレスポンスを返す関数です。</p>

<blockquote>
<p>filter_interface(レスポンス): レスポンス</p>
</blockquote>

<p>もしくは、オプションとしてRequestオブジェクトを第二引数で受け取ることもできます。</p>

<blockquote>
<p>filter_interface(レスポンス, Request): レスポンス</p>
</blockquote>

<p>Filter処理は、corniceの土台であるpyramidのレイヤーで実行されます。
この処理がエラーのエスポンスにも作用するかどうかは、確認できておらず不明です。</p>

<h2>チュートリアルのユーザー管理機能（前回の続き）</h2>

<p>前回の続きとして、ユーザー登録を写経します。</p>

<h3>ユーザー登録</h3>

<p>ユーザー登録の仕様は、POSTデータとして、ユーザー名を送信します。</p>

<p>ユニークチェックを行い、重複がなければ、</p>

<blockquote>
<p>ユーザー名: ランダムなハッシュ</p>
</blockquote>

<p>をディクショナリに保持させます。</p>

<p>まず、この入力値に対するValidatorを用意します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import os
</span><span class='line'>import binascii
</span><span class='line'>
</span><span class='line'>def validate_unique(request):
</span><span class='line'>    name = request.params.get('user', '')
</span><span class='line'>
</span><span class='line'>    if name == '':
</span><span class='line'>        request.errors.add('url', 'name', 'user is not passed ...')
</span><span class='line'>    if name in _USERS:
</span><span class='line'>        request.errors.add('url', 'name', 'This user exists !')
</span><span class='line'>    else:
</span><span class='line'>        user = { 'name':name, 'token': binascii.b2a_hex(os.urandom(20)) }
</span><span class='line'>        request.validated['user'] = user</span></code></pre></td></tr></table></div></figure>

<p>このValidatorを指定したユーザー登録処理を実装します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@users.post(validators=validate_unique)
</span><span class='line'>def create_user(request):
</span><span class='line'>  """Add a new user"""
</span><span class='line'>  user = request.validated['user']
</span><span class='line'>
</span><span class='line'>  _Users[user['name']] = user['token']
</span><span class='line'>
</span><span class='line'>  return { 'token': '%s-%s' % (user['name'], user['token']) }</span></code></pre></td></tr></table></div></figure>

<p><code>pserve cornice_tutorial.ini</code> でサービスを起動。</p>

<blockquote>
<p>curl -X POST http://localhost:6543/users -d user=ktz</p>
</blockquote>

<p>の場合</p>

<blockquote>
<p>{&quot;token&quot;: &quot;ktz-b&#39;04afcabc1348c9253be856ee81cde78a75185ca9&#39;&quot;}</p>
</blockquote>

<p>という出力が返され、
再度同じリクエストを送ると、</p>

<blockquote>
<p>{&quot;status&quot;: &quot;error&quot;, &quot;errors&quot;: [{&quot;location&quot;: &quot;url&quot;, &quot;description&quot;: &quot;This user exists !&quot;, &quot;name&quot;: &quot;name&quot;}]}</p>
</blockquote>

<p>というエラー出力が、</p>

<blockquote>
<p>curl -X POST http://localhost:6543/users</p>
</blockquote>

<p>の場合、</p>

<blockquote>
<p>{&quot;errors&quot;: [{&quot;description&quot;: &quot;user is not passed &#8230;&quot;, &quot;name&quot;: &quot;name&quot;, &quot;location&quot;: &quot;url&quot;}], &quot;status&quot;: &quot;error&quot;}</p>
</blockquote>

<p>が返され、Validatorが作用しているのが分かります。</p>

<p>また、</p>

<blockquote>
<p>curl http://localhost:6543/users</p>
</blockquote>

<p>のリクエストで、</p>

<blockquote>
<p>{&quot;users&quot;: {&quot;ktz&quot;: &quot;04afcabc1348c9253be856ee81cde78a75185ca9&quot;}}</p>
</blockquote>

<p>と返され、問題なく追加されいるようです。</p>

<h3>つづく</h3>

<h3>補足・・・</h3>

<blockquote>
<p>curl -X POST http://localhost:6543/users -d user=りたりん</p>
</blockquote>

<p>の場合、レスポンスは</p>

<blockquote>
<p>{&quot;token&quot;: &quot;\u308a\u305f\u308a\u3093-b&#39;a1ef940c4259833e8bd21da6b1a32a9b8b7e788f&#39;&quot;}</p>
</blockquote>

<p>のように、日本語が文字参照に変換された形となります。
これは、規定のレンダラである<code>json_renderer</code>が行っています。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cornice Tutorial (2)]]></title>
    <link href="http://ritalin.github.io/2013/06-12/cornice-tutorial-02/"/>
    <updated>2013-06-12T00:28:00+09:00</updated>
    <id>http://ritalin.github.io/2013/06-12/cornice-tutorial-02</id>
    <content type="html"><![CDATA[<h2>はじめに</h2>

<p>引き続き、公式サイトの<a href="http://cornice.readthedocs.org/en/latest/tutorial.html">チュートリアル</a>を写経していきます。
ちなみに完全な和訳を目指しているわけではないです。あしからず。</p>

<!-- more -->

<h2>サービスの作成</h2>

<p>サービスの実装は、<code>cornice_tutorial/views.py</code> に記述するようです。
中身を確認してみると・・・</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>""" Cornice services.
</span><span class='line'>"""
</span><span class='line'>from cornice import Service
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>hello = Service(name='hello', path='/', description="Simplest app")
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@hello.get()
</span><span class='line'>def get_info(request):
</span><span class='line'>    """Returns Hello in JSON."""
</span><span class='line'>    return {'Hello': 'World'}</span></code></pre></td></tr></table></div></figure>

<ul>
<li>6行目がサービスの定義</li>
<li>9 - 12行目がサービス（レスポンス）の実装</li>
</ul>

<p>となってるようです。</p>

<h3>サービス定義で指定するパラメータ</h3>

<p>6行目のサービス定義の中の詳細について、<a href="http://cornice.readthedocs.org/en/latest/api.html">公式マニュアル</a>より引用すると</p>

<ul>
<li>name (<em>Required</em>)

<ul>
<li>サービス名。全体でユニークな者にする必要がある</li>
</ul></li>
<li>path (<em>Required</em>)

<ul>
<li>サービスへのリクエストパス(URI)。全体でユニークする必要がある。</li>
</ul></li>
<li>description (Optional)

<ul>
<li>サービスの説明。</li>
</ul></li>
</ul>

<p>上記以外にもいくつかパラメータが用意されているようですが、それはいずれかの機会にでも・・・</p>

<h3>レスポンスの実装</h3>

<ul>
<li>9行目

<ul>
<li>このサービスで受け入れる(HTTP)メソッド</li>
<li>Get, Post, Put, Delete, Head, Optionが用意されている</li>
</ul></li>
<li>12行目

<ul>
<li>dictとして戻り値を指定することで、JSONオブジェクトとして処理されるHTTPレスポンスが構築される。</li>
<li>ver 0.14時点では、JSONしか返すことができない模様</li>
</ul></li>
</ul>

<p>では、チュートリアルに戻って、ユーザー一覧を実装してみる。
<code>cornice_tutorial/views.py</code> のサービス定義とレスポンス実装を削除し、代わりに以下のように記述。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>users = Service(name='users', path='/users', description="ユーザー管理サービス（一覧・追加・削除）")
</span><span class='line'>
</span><span class='line'>_USERS = {}
</span><span class='line'>
</span><span class='line'>@users.get()
</span><span class='line'>def list_users(request):
</span><span class='line'>    """登録されたすべてのユーザーを列挙 """
</span><span class='line'>    return { 'users': _USERS }</span></code></pre></td></tr></table></div></figure>

<p><code>pserve cornice_tutorial.ini</code> でサービスを起動し、</p>

<blockquote>
<p>curl http://localhost:6543/users</p>
</blockquote>

<p>を実行し、</p>

<blockquote>
<p>{&quot;users&quot;: {}}</p>
</blockquote>

<p>と出力されれば、とりあえずOKということで。</p>

<h3><a href="http://ritalin.github.io/2013/07-04/cornice-tutorial-03/">Cornice Tutorial (3)</a>へつづく&#8230;</h3>

<h3>おまけ</h3>

<p>Windows使いは、curlコマンドないので、Powershellから</p>

<blockquote>
<p>invoke-webrequest -method get http://localhost:6543/users</p>
</blockquote>

<p>または</p>

<blockquote>
<p>invoke-restmethod -method get http://localhost:6543/users</p>
</blockquote>

<p>とすればいいのかな？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cornice Tutorial (1)]]></title>
    <link href="http://ritalin.github.io/2013/06-04/cornice-tutorial-01/"/>
    <updated>2013-06-04T23:12:00+09:00</updated>
    <id>http://ritalin.github.io/2013/06-04/cornice-tutorial-01</id>
    <content type="html"><![CDATA[<h2>あらまし</h2>

<p>RESTサーバーを実装するための良いフレームワークはないかなと探していたところ、<a href="http://cornice.readthedocs.org/en/latest/index.html">Cornice</a>というpythonで実装されたフレームワークに出会いました。
CorniceはPyramidというWebアプリケーションフレームワークの上にのるものであり、
Pyramidのtemplate EnginがZPT-TAL由来のCameleonであることを知り、これは触ってみなければという気持ちになりました。</p>

<p>公式サイトには<a href="http://cornice.readthedocs.org/en/latest/tutorial.html">チャットサーバを実装するためのチュートリアル</a>があるので、
これをネタにPythonの勉強をしつつやって行こうかなと思います。</p>

<p>当方、Pythonに関しては、ドがつくほどの素人なので、あり得ない事し出すかも知れませんが生暖かく見守っていただければかと。</p>

<!-- more -->

<h2>環境構築</h2>

<p>公式サイトでは、Python 2.7で進めるようになってます。しかし<a href="https://github.com/mozilla-services/cornice">Github</a>のソースツリー眺めてたらPython 3.3対応ぽいことがコミットログとしてあがって上がっており、試したところとりあえずScaffoldingがうまくいくことが確認できたので、
あえて地雷覚悟でPython 3.3系で進めてみようかと思います。</p>

<h3>インストール</h3>

<blockquote>
<p><em>注意</em></p>

<p>公式サイトのチュートリアルでは、vitualenvで環境を用意してから実行してますが、お好みでどうぞ</p>

<p>私はpythonbrewのvenv上に構築しました。</p>
</blockquote>

<ul>
<li><a href="https://github.com/mozilla-services/cornice">Github</a>よりレポジトリをclone。</li>
</ul>

<blockquote>
<p>git clone git://github.com/mozilla-services/cornice.git</p>
</blockquote>

<ul>
<li>落としてきたソースツリーに入り、インストール実行。</li>
</ul>

<blockquote>
<p>cd /path/to/cornice
python ./setup.py install</p>
</blockquote>

<ul>
<li>インストールがうまくいったか確認。<code>pcreate -l</code>を実行し、以下のようにcorniceが表示されればOK。</li>
</ul>

<blockquote>
<p>Available scaffolds:</p>

<p>&#8230;</p>

<p>cornice:  A Cornice application</p>

<p>&#8230;</p>
</blockquote>

<h3>プロジェクト作成</h3>

<ul>
<li>適当なワークフォルダに行き、以下のコマンドを実行。

<ul>
<li>プロジェクト名は <em>cornice_tutorial</em> とします。</li>
</ul></li>
</ul>

<blockquote>
<p>pcreate -t cornice cornice_tutorial</p>
</blockquote>

<p>ここで、プロジェクト名に、ハイフン(-)は使用しない方がヨサゲ。区切り文字が必要であれば、かわりにアンダースコア(_)を使用する。</p>

<ul>
<li>プロジェクトの中に入り、開発用の実行環境を構成する</li>
</ul>

<blockquote>
<p>cd /path/to/cornice_tutorial</p>

<p>python ./setup.py develop</p>
</blockquote>

<h3>動作確認</h3>

<ul>
<li>以下のコマンドを実行し、サービスを起動する</li>
</ul>

<blockquote>
<p>pserve cornice_tutorial.ini</p>
</blockquote>

<ul>
<li>WEBブラウザで、<code>http://localhost:6543</code>を訪れ、</li>
</ul>

<blockquote>
<p>{&#39;Hello&#39;: &#39;World&#39;}</p>
</blockquote>

<p>と出ればOK。</p>

<h3><a href="http://ritalin.github.io/2013/06-12/cornice-tutorial-02/">Cornice Tutorial (2)</a>へつづく・・・</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mahout in Action読了]]></title>
    <link href="http://ritalin.github.io/2013/05-29/mahout-in-action/"/>
    <updated>2013-05-29T23:46:00+09:00</updated>
    <id>http://ritalin.github.io/2013/05-29/mahout-in-action</id>
    <content type="html"><![CDATA[<p>なんとか最後まで読み通せました。
まとめながら読んでいたので、すごく時間がかかってしまいました。</p>

<h2>どんな本？</h2>

<p>この本は、機械学習の処理系およびライブラリである<a href="http://mahout.apache.org">Apache Mohout</a>の実践ガイドであり、
Mahoutを通して機械学習について体系立てて学ぶことができるようになってます。</p>

<!-- more -->

<p>全体で３部構成になっており、</p>

<ul>
<li>レコメンデーション</li>
<li>クラスタリング</li>
<li>分類</li>
</ul>

<p>のそれぞれについて、理論 -&gt; 実装 -&gt; ケーススタディが著されています。</p>

<p>理論と言っても、数式が嫌というほど出てくるわけではなく、図や表でしっかり補足されているため、
わたしのような機械学習をよく分かってない者でも十分理解できる内容でした。</p>

<p>またMahoutは分散環境にも対応しており、<a href="http://hadoop.apache.org">Apache Hadoop</a>と組み合わせて実施することができます。
分散環境に関しても十分ページを割いているので、Mahoutを通してHadoopを学習する教材としても有効だと思います。</p>

<p>そのほか、<a href="http://aws.amazon.com/jp/elasticmapreduce/">Amazon Elastic MapReduce (Amazon EMR)</a>での導入方法も詳しく書かれているのも特徴でしょう。</p>

<p>翻訳の品質については、さすがO&#39;REILLYということもあり、読みづらいと感じることはなかったです。ただ少し訳が堅い気はしましたが。</p>

<h2>どんな人向け？</h2>

<p>これから機械学習をやってみようかなという人にはうってつけだと思います。</p>

<h2>リンク</h2>

<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ritalin09-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4873115841" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type Provider Memo]]></title>
    <link href="http://ritalin.github.io/2013/04-04/type-provider-memo/"/>
    <updated>2013-04-04T23:04:00+09:00</updated>
    <id>http://ritalin.github.io/2013/04-04/type-provider-memo</id>
    <content type="html"><![CDATA[<p>TypeProvider実装のための記憶保管のためにメモとして残す</p>

<!-- more -->

<ul>
<li><p>FSharp.Data.dllを拾ってくる</p>

<ul>
<li>Nugetで取って来れる</li>
<li>TypeProviderのための骨格抽象実装が用意されているので、ありがたくご相伴</li>
</ul></li>
<li><p>open Microsoft.FSharp.Core.CompilerServices</p>

<ul>
<li>TypeProviderAttibuteが定義されている</li>
</ul></li>
<li><p>open ProviderImplementation.ProvidedTypes</p>

<ul>
<li>TypeProviderForNamespacesクラス

<ul>
<li>TypeProviderの親クラスとして使用する</li>
</ul></li>
<li>ProvidedTypeDefinitionクラス

<ul>
<li>TypeProvider内部で使用する型を定義するためのクラス</li>
<li>Typeクラスから派生</li>
</ul></li>
</ul></li>
<li><p>TypeProviderメタクラスのdo束縛にて</p>

<ul>
<li>Providerの型定義

<ul>
<li>ProvidedTypeDefinitionをインスタンス化</li>
<li>ProvidedTypeDefinition#AddXmlDoc呼ぶ

<ul>
<li>ヘルプメッセージ追加のため</li>
<li>たぶん必須ではないとは思う</li>
</ul></li>
<li>ProvidedTypeDefinition#DefineStaticParametersを呼ぶ

<ul>
<li>TypeProviderの引数定義</li>
<li>第一引数はList<ProvidedStaticParameter></li>
<li>第二引数は引数型をインスタンス化するための高階関数

<ul>
<li>string -&gt; obj[] -&gt; ProvidedTypeDefinition</li>
</ul></li>
<li>必須</li>
</ul></li>
</ul></li>
<li>TypeProviderメタクラスのAddNamespaceメソッド呼ぶ

<ul>
<li>これでF# コンパイラに登録される？</li>
</ul></li>
</ul></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MochaでJavascript以外を指定してテストしたい]]></title>
    <link href="http://ritalin.github.io/2013/03-22/mocha-testing-apart-from-js/"/>
    <updated>2013-03-22T20:01:00+09:00</updated>
    <id>http://ritalin.github.io/2013/03-22/mocha-testing-apart-from-js</id>
    <content type="html"><![CDATA[<p>Node.js用テスティング環境であるmochaでは、compilersオプションを指定することにより、Javascript以外のコードも扱えるみたいです。
が、しかし、公式のマニュアルを読んでも、さっぱりやり方が分からなかったので、がんばってMochaのコードを追いかけてみました。</p>

<!-- more -->

<h2>compilerオプションについて</h2>

<p>compilerオプションでは、</p>

<blockquote>
<p>&quot;拡張子&quot;:&quot;コンパイルモジュール&quot;</p>
</blockquote>

<p>を指定します。
これは、<strong>指定した拡張子のファイルに遭遇したら、指定したコンパイルモジュールでJavascriptにコンパイルしてね</strong> というおまじないになります。
規定では、<strong>.js</strong> のみが対象となっています。</p>

<p>Mochaは、テスト対象のフォルダを再帰的に走査して、遭遇したファイルが.jsと指定された拡張子以外であれば、無視するような仕掛けとなっています。</p>

<h2>Node.jsでJavascript以外を扱う仕組み</h2>

<p>対象の拡張子のファイルに遭遇すると、Mochaは、そのファイルをrequireで読み込もうとします。
Node.jsのマニュアルで <strong>require</strong> を調べると、</p>

<ul>
<li>.js</li>
<li>.json</li>
<li>.node</li>
</ul>

<p>が読み込み対象と書かれています。
ではそれ以外のファイルがきた時は、どうなってしまうのでしょう？</p>

<p>Node.jsでは、上記以外のファイルの場合、<strong>require.extensions</strong> からの読み込みを試みます。
require.extensionsは、拡張子をキーに、指定されたファイルをJavascriptに変換する関数が登録された辞書です。</p>

<p>この関数の型は、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function (module, filename) {
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>となっており、ここで、</p>

<ul>
<li>module - Moduleモジュール</li>
<li>filename - 読み込むファイル名</li>
</ul>

<h2>Mochaに渡すコンパイルモジュールの仕様</h2>

<p>仕様と言えるような、大それたものはなく、Javascriptに変換する関数を実装し、それを単に上述の<strong>require.extensions</strong> に追加するだけです。</p>

<p>この関数の実装において、一つ重要な点があります。
それは、Javascriptのコードに変換後、module._compile(&lt;変換されたコード&gt;)という非公開の関数を呼ぶということです。</p>

<p>この <strong>module._compile</strong> が呼ばれることで、ロードが完了する仕組みとなっているようです。</p>

<p>requireの呼び出し元は、module._compileが呼ばれるまで、ブロックされるようになっているため、Javascriptへの変換関数が非同期的に実装（fs.readFile等）されていても、まったく問題ないです。</p>

<p>変換関数の具体的な実装は、coffee-scriptモジュールを読んでみるよいでしょう。</p>

<h2>例：Haxeの場合</h2>

<p>Haxeには、mocha.js-haxeという、Mocha用のコードに変換するための拡張ライブラリが公開されています。
そこで、Haxeのオプション記述ファイル(.hxml)に対してコンパイルモジールを作成しておけば、MochaでHaxeのコードを直接テストできるようになります。</p>

<p>Javascriptへの変換関数関数の仕様として、</p>

<ol>
<li>child_processモジュールのexec関数で、hxmlファイルを渡して、HaxeのコードをJavascriptコンパイルする。</li>
<li>コンパイルしたファイルを、fsモジュールのreadFile（またはfs.readFileSync）で読み込んで、コードを取得する。</li>
<li>module._compileにそのコードを渡す。</li>
</ol>

<p>とすれば、よいでしょう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Factoryの具象クラスをインスタンスするのは誰？]]></title>
    <link href="http://ritalin.github.io/2013/01-10/factory-method/"/>
    <updated>2013-01-10T22:04:00+09:00</updated>
    <id>http://ritalin.github.io/2013/01-10/factory-method</id>
    <content type="html"><![CDATA[<h2>Simple Factory</h2>

<p>というのが、デザインパターンとしてあるのですね。今日Twitter上のTLに流れてきて、気になってググってみたら、<a href="http://d.hatena.ne.jp/asakichy/20090414/1239718537">Strategic Choice</a>さんのブログに行き着きました。</p>

<p>Factory Methodとの違いは、Factoryを具象クラス一本に絞ったという感じでしょうか。</p>

<!-- more -->

<h2>Factoryの具象クラスをインスタンスするのは誰？</h2>

<p>さて本題。Factory Methodは、FactoryとProductの両方について、抽象層にインターフェースを設け、具象層に各インターフェースの具象クラスを置きます。ClientオブジェクトはFactoryのインターフェースを通して具象Productを生成し、インターフェースとして取得する形となります。</p>

<p>前から気になっていたのですが、誰かが具象Factoryを生成してあげる必要があります。ClientがFactoryをインスタンス化するのであれば、ClientはProductの実装への依存はなくせますが、依然factoryの実装には依存してしまいます。</p>

<p>じゃぁ、FactoryのためのFactoryが必要？</p>

<p>そのFactoryのためのFactory生成は誰が行うの？</p>

<p>と堂々巡りしてしまい、私の中では「いらない子」扱いのパターンでした。</p>

<h2>DIコンテナさん登場</h2>

<p>Factoryの具象クラスへの依存をどう解決すべきか分からず、もやっとしていたのですが、素直にDIコンテナさんに任せちゃえばいいんじゃないかなと、ここ最近気づきました。</p>

<p>しかし、DIコンテナの機能として、たいてい遅延実行をサポートしているので、遅延実行のための高階関数をFactory代わりにしてしまえる気がします。（使う側のClientはどんな形であれ依存が解決できればいいはずなので）</p>

<p>結局、Factory Methodいらなくね？と、現在進行形で「いらない子」になってるのでした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DCI (Data - Context - Interaction)のパイプライン化]]></title>
    <link href="http://ritalin.github.io/2012/12-27/pipelined-dci/"/>
    <updated>2012-12-27T21:56:00+09:00</updated>
    <id>http://ritalin.github.io/2012/12-27/pipelined-dci</id>
    <content type="html"><![CDATA[<p>なんだか最近、DCIの話題が花盛りですね。</p>

<p>さて、<a href="https://groups.google.com/forum/?fromgroups=#!topic/object-composition/u-aVj_FexM4">Google Group: object-composition</a>にて、DCIとMVCの関係について、面白い考察を行っている人がいます。</p>

<p>曰く、Model表現をViewのための表現に変換するためのRole (Interaction) をContextに組み込むのはどうかと提起しています。</p>

<p>私の中では、アプリケーションにおけるDCIの位置づけは、Modelのなかを覗き込んだときに、そこにいるものと思っています。</p>

<p>Modelの中の構成体ゆえ、View表現を持つことはあまり良いものではないと考えています。
しかし、View表現への変換をRoleとして組み込むのは面白いと思いました。</p>

<p>そこで表題に繋がるわけですが、Model層を構成するDCIをより大きな、Dとみなし、そこにView表現に変換するRoleを組み込んだらどうなのかなと思いました。</p>

<!-- more -->

<p>図にするとこんな感じ
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Context<em>1
</span><span class='line'>    |- Interraction</em>1 (View transformation)
</span><span class='line'>    |- Context<em>2 (Data</em>1)
</span><span class='line'>           |- Interraction<em>2 (Model transformation)
</span><span class='line'>           |- Data</em>2 (Domain data)</span></code></pre></td></tr></table></div></figure></p>

<p>Context<em>2の中でドメインデータであるData</em>2がInterraction<em>2と作用し、次いでContext</em>1の中でContext<em>1での生成物とInterraction</em>1が作用する。という処理の流れになります。</p>

<p>言い換えると、Context<em>2の反応の後Context</em>1の反応が行われるというパイプラインを構成していると見ることが出来ます。</p>

<p>アプリケーション全体としては、最終的に出来上がった表現をViewにバインドするというModel - Viewという単純なアーキテクチャにすることができるように思えます。</p>

<p>また、２フェーズのパイプラインを例示しましたが、２フェーズ以上でも同様にパイプをつないでいくだけになります。</p>

<p>うーん、なんてモナディック。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rhino.Mocks tips]]></title>
    <link href="http://ritalin.github.io/2012/12-20/rhino-mocks-tips/"/>
    <updated>2012-12-20T21:27:00+09:00</updated>
    <id>http://ritalin.github.io/2012/12-20/rhino-mocks-tips</id>
    <content type="html"><![CDATA[<p>いくつか引っかかったので、忘れないうちにメモとして残しとく。</p>

<!-- more -->

<h2>プロパティをモック</h2>

<p>具象クラスのモックを作る場合、対象のメソッドやプロパティをvirtualにする必要がある。
モック目的のためだけにvirtualにするのは気が重い。</p>

<p>この場合、インターフェースを切り出し、インターフェースからモック作れば心配無用。
モックから戻り値を取得するためにReturnやDoも必要。</p>

<h2>NUnitで使う際の注意点</h2>

<ul>
<li>連続実行したとき、2つ目以降のテストケースが失敗する</li>
</ul>

<p>Rhino.Mocksに限らないが、フィールドの初期化子でインスタンス化した場合に発生。
必ずSetUp属性、FixtureSetpu属性、または各テストコード内で初期化すること。</p>

<p>GOOS本(p.26)にもちゃんと書かれてる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[（みんなには内緒だよ）]]></title>
    <link href="http://ritalin.github.io/2012/12-17/hentai-advent-2012/"/>
    <updated>2012-12-17T01:00:00+09:00</updated>
    <id>http://ritalin.github.io/2012/12-17/hentai-advent-2012</id>
    <content type="html"><![CDATA[<p>これは『<a href="http://atnd.org/events/33835">HENTAI Advent Calendar 2012 - 変態アドベントカレンダー</a>』の記事です。</p>

<p><img src="http://atnd.org/event_images/0004/9574/__________2012-11-03_23.31.02_original.png" alt="Picture banner"></p>

<p>前日（16日目）はs_kozake さんの「<a href="http://ameblo.jp/kozake/entry-11428146545.html">変態ルーレット2.0</a>」でした。</p>

<p>VirtualBoxではサポートされていない、Moac OS X Mountain LionをHackintosh (Hackロム)等に頼ること無くインストールできたので、こっそり後悔します。</p>

<p>実際にやったのはひと月前なので、その時の記憶をもとにお送りいたします（再度インストールするのがメンドイから）</p>

<!-- more -->

<h2>前提</h2>

<ul>
<li>VirtualBoxは、その時点で最新のバージョンをインストールしておく

<ul>
<li>入れた当時は、v4.2.x</li>
</ul></li>
</ul>

<h2>手順</h2>

<h3>インストーラをダウンロードする</h3>

<h4>1. App StoreからMountain Lionを購入（ちゃんと購入しましょう）。</h4>

<p><img src="../../../images/items/20121217/step1.png" alt="Picture Step1"></p>

<h4>2. 自動的にインストーラが起動したら、メニューから「OS X インストールを終了」を選び、即終了させる</h4>

<p><img src="../../../images/items/20121217/step2.png" alt="Picture Step2"></p>

<h3>ディスクイメージ抽出</h3>

<h4>3. アプリケーションフォルダにインストーラがいるはずなので探し出す</h4>

<ul>
<li>コンテキストメニューの「パッケージの内容を表示」を選び中に入る。</li>
<li>Contents/SharedSupport/InstallESD.dmg があることを確認する。</li>
</ul>

<h4>4. ディスクユーティリティを起動する</h4>

<p><img src="../../../images/items/20121217/step4.png" alt="Picture Step4-1"></p>

<ul>
<li>(1)の欄にInstallESD.dmgをD&amp;D</li>
<li><p>(1)の欄にInstallESD.dmgを選択し、(2)「変換」を押す。</p></li>
<li><p>変換先のフォーマットをDVD / CDマスターにし、どっか適当なところに保存する。</p></li>
</ul>

<p><img src="../../../images/items/20121217/step4-2.png" alt="Picture Step4-2"></p>

<ul>
<li>変換待つ・・・</li>
</ul>

<h3>インストール作業</h3>

<h4>5. VirtualBoxの仮想マシンを追加</h4>

<p>{<img src="../../../images/items/20121217/step5.png" alt="Picture Step5"></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">タイプ：Mac OS X
バージョン：Mac OS X (64 bit)
</code></pre></div>
<ul>
<li>以降は通常通りすすめて作成する</li>
<li>作成したVMの設定を開き、ストレージのCD /DVDに4.で作成したディスクイメージを指定する。</li>
</ul>

<p>{<img src="../../../images/items/20121217/step5-2.png" alt="Picture Step5-2"></p>

<h4>6. VMを実行する</h4>

<p>（ごめんね、画像無くて）</p>

<ul>
<li>再セットアップが開始する（結構時間かかる）</li>
<li><p>VM内のディスクユーティリティを起動し、パーティションをフォーマットする（不要かもしれない）</p>

<ul>
<li>Mac OS 拡張（ジャーナリング）、GUIDパーティションテーブルを選ぶこと</li>
</ul></li>
<li><p>ディスクユーティリティ終了→インストールアプリ起動</p></li>
<li><p>設問に従ってポチポチ</p></li>
<li><p>インストール始まる。</p></li>
</ul>

<p>最後までいくと自動的に再起動する。</p>

<p>完了かと思いきや、インストールがおこなわれてる。</p>

<p>２ループ目は不明だったので、静観してたけど、３ループ目も同じように進もうとしたため、VMを強制停止する（ウインドウ閉じればアラートでる）</p>

<p>たぶんリカバリインストールが始まってたぽい気がする。</p>

<h4>7. VMの設定を開きCD / DVDをアンマウントする</h4>

<h4>8. 再度、VMを実行する</h4>

<p>インストールプロセスの続きが実行された。</p>

<p>言語とかネットワーク設定とか聞いてきたような気がするけど、必須入力以外はすべてスキップしたような（もう覚えてない）</p>

<p>VirtualBoxの関係上なのか、英語版にされる。</p>

<p><img src="../../../images/items/20121217/evidence.png" alt="Picture evidence"></p>

<h2>そのた、雑多なこと</h2>

<ul>
<li>こんな起動の裏側が見れるよ。</li>
</ul>

<p><img src="../../../images/items/20121217/omake.png" alt="Picture omake"></p>

<ul>
<li><p>当方、Sanday BridgeのMacBookAir 13&#39;&#39;松特盛りですが、起動に５分ぐらいかかります。気長に待ちましょう。</p></li>
<li><p>２本指スクロール</p></li>
</ul>

<p>はじめ効かないかと思ったけどSnow Leopard基準なので、Mountain Lionと逆なだけでした。</p>

<ul>
<li>放置しておくと、結構な頻度でフリーズ状態になります。しょうがないね。</li>
</ul>

<h2>まとめ</h2>

<p><strong>変態</strong> というよりは、どう見ても、真っクロに限りなく近いクロです。どうもあ（ry</p>

<p>明日(18日目)は<a href="http://maruta.be/linegod/1">nyaarto</a>さんです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gist.github.com埋め込みテスト]]></title>
    <link href="http://ritalin.github.io/2012/12-12/embed-gist/"/>
    <updated>2012-12-12T21:14:00+09:00</updated>
    <id>http://ritalin.github.io/2012/12-12/embed-gist</id>
    <content type="html"><![CDATA[<p><a href="gist.github.com">gist</a>のリニューアルで、埋め込んだコードが崩れだしたので確認。</p>

<!-- more -->

<div><script src='https://gist.github.com/4147464.js?file=RhinoMocksCreationExtensions.cs'></script>
<noscript><pre><code>using System;
using Rhino.Mocks;

namespace Samples {
    internal static class RhinoMocksCreationExtensions {
        /// &lt;summary&gt;Generates a stub without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        /// &lt;param name=&quot;argumentsForConstructor&quot;&gt;Arguments for &lt;typeparamref name=&quot;T&quot;/&gt;&#39;s constructor&lt;/param&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The &lt;see cref=&quot;Type&quot;/&gt; of stub to create.&lt;/typeparam&gt;
        /// &lt;returns&gt;The stub&lt;/returns&gt;
        /// &lt;seealso cref=&quot;Stub{T}&quot;/&gt;
        public static T GenerateStubHelper&lt;T&gt;(this MockRepository repository, params object[] argumentsForConstructor) where T : class {
            return CreateMockInReplay(repository, repo =&gt; (T)repo.Stub(typeof(T), argumentsForConstructor));
        }

        /// &lt;summary&gt;Generates a stub without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;The &lt;see cref=&quot;Type&quot;/&gt; of stub.&lt;/param&gt;
        /// &lt;param name=&quot;argumentsForConstructor&quot;&gt;Arguments for the &lt;paramref name=&quot;type&quot;/&gt;&#39;s constructor.&lt;/param&gt;
        /// &lt;returns&gt;The stub&lt;/returns&gt;
        /// &lt;seealso cref=&quot;Stub&quot;/&gt;
        public static object GenerateStubHelper(this MockRepository repository, Type type, params object[] argumentsForConstructor) {
            return CreateMockInReplay(repository, repo =&gt; repo.Stub(type, argumentsForConstructor));
        }

        /// &lt;summary&gt;Generate a mock object without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;type &lt;see cref=&quot;Type&quot;/&gt; of mock object to create.&lt;/typeparam&gt;
        /// &lt;param name=&quot;argumentsForConstructor&quot;&gt;Arguments for &lt;typeparamref name=&quot;T&quot;/&gt;&#39;s constructor&lt;/param&gt;
        /// &lt;returns&gt;the mock object&lt;/returns&gt;
        /// &lt;seealso cref=&quot;DynamicMock{T}&quot;/&gt;
        public static T GenerateMockHelper&lt;T&gt;(this MockRepository repository, params object[] argumentsForConstructor) where T : class {
            return CreateMockInReplay(repository, r =&gt; r.DynamicMock&lt;T&gt;(argumentsForConstructor));
        }

        /// &lt;summary&gt;Generate a multi-mock object without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The &lt;c&gt;typeof&lt;/c&gt; object to generate a mock for.&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TMultiMockInterface1&quot;&gt;A second interface to generate a multi-mock for.&lt;/typeparam&gt;
        /// &lt;param name=&quot;argumentsForConstructor&quot;&gt;Arguments for &lt;typeparamref name=&quot;T&quot;/&gt;&#39;s constructor&lt;/param&gt;
        /// &lt;returns&gt;the multi-mock object&lt;/returns&gt;
        /// &lt;seealso cref=&quot;DynamicMultiMock(System.Type,System.Type[],object[])&quot;/&gt;
        public static T GenerateMockHelper&lt;T, TMultiMockInterface1&gt;(this MockRepository repository, params object[] argumentsForConstructor) {
            return (T)RhinoMocksCreationExtensions.GenerateMockHelper(
                repository,
                typeof(T), new Type[] { typeof(TMultiMockInterface1) }, argumentsForConstructor);
        }

        /// &lt;summary&gt;Generate a multi-mock object without without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The &lt;c&gt;typeof&lt;/c&gt; object to generate a mock for.&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TMultiMockInterface1&quot;&gt;An interface to generate a multi-mock for.&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TMultiMockInterface2&quot;&gt;A second interface to generate a multi-mock for.&lt;/typeparam&gt;
        /// &lt;param name=&quot;argumentsForConstructor&quot;&gt;Arguments for &lt;typeparamref name=&quot;T&quot;/&gt;&#39;s constructor&lt;/param&gt;
        /// &lt;returns&gt;the multi-mock object&lt;/returns&gt;
        /// &lt;seealso cref=&quot;DynamicMultiMock(Type,Type[],object[])&quot;/&gt;
        public static T GenerateMockHelper&lt;T, TMultiMockInterface1, TMultiMockInterface2&gt;(this MockRepository repository, params object[] argumentsForConstructor) {
            return (T)RhinoMocksCreationExtensions.GenerateMockHelper(
                repository,
                typeof(T), new Type[] { typeof(TMultiMockInterface1), typeof(TMultiMockInterface2) }, argumentsForConstructor
            );
        }

        /// &lt;summary&gt;Creates a multi-mock without without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;The type of mock to create, this can be a class&lt;/param&gt;
        /// &lt;param name=&quot;extraTypes&quot;&gt;Any extra interfaces to add to the multi-mock, these can only be interfaces.&lt;/param&gt;
        /// &lt;param name=&quot;argumentsForConstructor&quot;&gt;Arguments for &lt;paramref name=&quot;type&quot;/&gt;&#39;s constructor&lt;/param&gt;
        /// &lt;returns&gt;the multi-mock object&lt;/returns&gt;
        /// &lt;seealso cref=&quot;DynamicMultiMock(System.Type,System.Type[],object[])&quot;/&gt;
        public static object GenerateMockHelper(this MockRepository repository, Type type, Type[] extraTypes, params object[] argumentsForConstructor) {
            return CreateMockInReplay(repository, r =&gt; r.DynamicMultiMock(type, extraTypes, argumentsForConstructor));
        }

        ///&lt;summary&gt;Creates a strict mock without without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        ///&lt;param name=&quot;argumentsForConstructor&quot;&gt;Any arguments required for the &lt;typeparamref name=&quot;T&quot;/&gt;&#39;s constructor&lt;/param&gt;
        ///&lt;typeparam name=&quot;T&quot;&gt;The type of mock object to create.&lt;/typeparam&gt;
        ///&lt;returns&gt;The mock object with strict replay semantics&lt;/returns&gt;
        /// &lt;seealso cref=&quot;StrictMock{T}&quot;/&gt;
        public static T GenerateStrictMockHelper&lt;T&gt;(this MockRepository repository, params object[] argumentsForConstructor) {
            return CreateMockInReplay(repository, r =&gt; r.StrictMock&lt;T&gt;(argumentsForConstructor));
        }

        ///&lt;summary&gt;Creates a strict multi-mock without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        ///&lt;param name=&quot;argumentsForConstructor&quot;&gt;Any arguments required for the &lt;typeparamref name=&quot;T&quot;/&gt;&#39;s constructor&lt;/param&gt;
        ///&lt;typeparam name=&quot;T&quot;&gt;The type of mock object to create, this can be a class.&lt;/typeparam&gt;
        ///&lt;typeparam name=&quot;TMultiMockInterface1&quot;&gt;An interface to generate a multi-mock for, this must be an interface!&lt;/typeparam&gt;
        ///&lt;returns&gt;The multi-mock object with strict replay semantics&lt;/returns&gt;
        /// &lt;seealso cref=&quot;StrictMultiMock(System.Type,System.Type[],object[])&quot;/&gt;
        public static T GenerateStrictMockHelper&lt;T, TMultiMockInterface1&gt;(this MockRepository repository, params object[] argumentsForConstructor) {
            return (T)RhinoMocksCreationExtensions.GenerateStrictMockHelper(
                repository,
                typeof(T), new Type[] { typeof(TMultiMockInterface1) }, argumentsForConstructor
            );
        }

        ///&lt;summary&gt;Creates a strict multi-mock without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        ///&lt;param name=&quot;argumentsForConstructor&quot;&gt;Any arguments required for the &lt;typeparamref name=&quot;T&quot;/&gt;&#39;s constructor&lt;/param&gt;
        ///&lt;typeparam name=&quot;T&quot;&gt;The type of mock object to create, this can be a class.&lt;/typeparam&gt;
        ///&lt;typeparam name=&quot;TMultiMockInterface1&quot;&gt;An interface to generate a multi-mock for, this must be an interface!&lt;/typeparam&gt;
        ///&lt;typeparam name=&quot;TMultiMockInterface2&quot;&gt;A second interface to generate a multi-mock for, this must be an interface!&lt;/typeparam&gt;
        ///&lt;returns&gt;The multi-mock object with strict replay semantics&lt;/returns&gt;
        ///&lt;seealso cref=&quot;StrictMultiMock(System.Type,System.Type[],object[])&quot;/&gt;
        public static T GenerateStrictMockHelper&lt;T, TMultiMockInterface1, TMultiMockInterface2&gt;(this MockRepository repository, params object[] argumentsForConstructor) {
            return (T)RhinoMocksCreationExtensions.GenerateStrictMockHelper(
                repository,
                typeof(T), new Type[] { typeof(TMultiMockInterface1), typeof(TMultiMockInterface2) }, argumentsForConstructor
            );
        }

        ///&lt;summary&gt;Creates a strict multi-mock without needing a &lt;see cref=&quot;MockRepository&quot;/&gt;&lt;/summary&gt;
        ///&lt;param name=&quot;type&quot;&gt;The type of mock object to create, this can be a class&lt;/param&gt;
        ///&lt;param name=&quot;extraTypes&quot;&gt;Any extra interfaces to generate a multi-mock for, these must be interaces!&lt;/param&gt;
        ///&lt;param name=&quot;argumentsForConstructor&quot;&gt;Any arguments for the &lt;paramref name=&quot;type&quot;/&gt;&#39;s constructor&lt;/param&gt;
        ///&lt;returns&gt;The strict multi-mock object&lt;/returns&gt;
        /// &lt;seealso cref=&quot;StrictMultiMock(System.Type,System.Type[],object[])&quot;/&gt;
        public static object GenerateStrictMockHelper(this MockRepository repository, Type type, Type[] extraTypes, params object[] argumentsForConstructor) {
            if (extraTypes == null) extraTypes = new Type[0];
            if (argumentsForConstructor == null) argumentsForConstructor = new object[0];

            return CreateMockInReplay(repository, r =&gt; r.StrictMultiMock(type, extraTypes, argumentsForConstructor));
        }

        ///&lt;summary&gt;
        ///&lt;/summary&gt;
        ///&lt;param name=&quot;argumentsForConstructor&quot;&gt;&lt;/param&gt;
        ///&lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        ///&lt;returns&gt;&lt;/returns&gt;
        public static T GeneratePartialMockHelper&lt;T&gt;(this MockRepository repository, params object[] argumentsForConstructor) {
            return (T)RhinoMocksCreationExtensions.GeneratePartialMockHelper(
                repository,
                typeof(T), new Type[0], argumentsForConstructor
            );
        }

        ///&lt;summary&gt;
        ///&lt;/summary&gt;
        ///&lt;param name=&quot;argumentsForConstructor&quot;&gt;&lt;/param&gt;
        ///&lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        ///&lt;typeparam name=&quot;TMultiMockInterface1&quot;&gt;&lt;/typeparam&gt;
        ///&lt;returns&gt;&lt;/returns&gt;
        public static T GeneratePartialMockHelper&lt;T, TMultiMockInterface1&gt;(this MockRepository repository, params object[] argumentsForConstructor) {
            return (T)RhinoMocksCreationExtensions.GeneratePartialMockHelper(
                repository,
                typeof(T), new Type[] { typeof(TMultiMockInterface1) }, argumentsForConstructor
            );
        }

        ///&lt;summary&gt;
        ///&lt;/summary&gt;
        ///&lt;param name=&quot;argumentsForConstructor&quot;&gt;&lt;/param&gt;
        ///&lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        ///&lt;typeparam name=&quot;TMultiMockInterface1&quot;&gt;&lt;/typeparam&gt;
        ///&lt;typeparam name=&quot;TMultiMockInterface2&quot;&gt;&lt;/typeparam&gt;
        ///&lt;returns&gt;&lt;/returns&gt;
        public static T GeneratePartialMockHelper&lt;T, TMultiMockInterface1, TMultiMockInterface2&gt;(this MockRepository repository, params object[] argumentsForConstructor) {
            return (T)RhinoMocksCreationExtensions.GeneratePartialMockHelper(
                repository,
                typeof(T), new Type[] { typeof(TMultiMockInterface1), typeof(TMultiMockInterface2) }, argumentsForConstructor
            );
        }

        ///&lt;summary&gt;
        ///&lt;/summary&gt;
        ///&lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        ///&lt;param name=&quot;extraTypes&quot;&gt;&lt;/param&gt;
        ///&lt;param name=&quot;argumentsForConstructor&quot;&gt;&lt;/param&gt;
        ///&lt;returns&gt;&lt;/returns&gt;
        public static object GeneratePartialMockHelper(this MockRepository repository, Type type, Type[] extraTypes, params object[] argumentsForConstructor) {
            return CreateMockInReplay(repository, r =&gt; r.PartialMultiMock(type, extraTypes, argumentsForConstructor));
        }

        /// &lt;summary&gt;
        /// Generate a mock object with dynamic replay semantics and remoting without needing the mock repository
        /// &lt;/summary&gt;
        public static T GenerateDynamicMockWithRemotingHelper&lt;T&gt;(this MockRepository repository, params object[] argumentsForConstructor) {
            return CreateMockInReplay(repository, r =&gt; r.DynamicMockWithRemoting&lt;T&gt;(argumentsForConstructor));
        }

        /// &lt;summary&gt;
        /// Generate a mock object with strict replay semantics and remoting without needing the mock repository
        /// &lt;/summary&gt;
        public static T GenerateStrictMockWithRemotingHelper&lt;T&gt;(this MockRepository repository, params object[] argumentsForConstructor) where T : class {
            return CreateMockInReplay(repository, r =&gt; r.StrictMockWithRemoting&lt;T&gt;(argumentsForConstructor));
        }

        private static T CreateMockInReplay&lt;T&gt;(MockRepository repository, Func&lt;MockRepository, T&gt; createMock) {
            var mockObject = createMock(repository);
            repository.Replay(mockObject);

            return mockObject;
        }
    }
}
</code></pre></noscript></div>

<p>相変わらず、行番号はずれたままだけど、コードはそれっぽく表示されるようにはなった。</p>

<p>Octopressでの変更点は、sass/parts/_article.scssの以下の行を削除した</p>

<ul>
<li>line 24 ( line-height: 2 )</li>
<li>line 25 ( text-align: justify ) </li>
<li>line 98 - 100 ( td{text-align: center;} )</li>
</ul>

<p>一桁の行番号が、横並びになるのは、github.comが発行するgistのjavascriptに書かれたhtmlの不備っぽい。
具体的には、</p>

<ul>
<li>td class=&quot;line_numbers&quot;を</li>
<li>td class=&quot;line_numbers gist-line-numbers&quot;</li>
</ul>

<p>にしたら、治ったように見えた（がんばって報告した）。</p>

<p>やれやれだぜ。</p>
]]></content>
  </entry>
  
</feed>
