<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Since 1975]]></title>
  <link href="http://ritalin.github.io/atom.xml" rel="self"/>
  <link href="http://ritalin.github.io/"/>
  <updated>2015-06-03T22:16:13+09:00</updated>
  <id>http://ritalin.github.io/</id>
  <author>
    <name><![CDATA[ktz_alias]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Omelet Reference(Draft) 4]]></title>
    <link href="http://ritalin.github.io/2015/06-03/omelet-reference-draft-4/"/>
    <updated>2015-06-03T20:02:06+09:00</updated>
    <id>http://ritalin.github.io/2015/06-03/omelet-reference-draft-4</id>
    <content type="html"><![CDATA[<h2>エンティティ</h2>

<p>エンティティは、値を詰め込み、DAOのパラメータとして渡したり、結果セットを詰め替えて返すために用いるオブジェクトです。</p>

<h3>エンティティの定義</h3>

<p>エンティティはドメイン同様クラスですが、ドメインとは異なり何か別のクラスを継承する必要はありません。</p>

<p>ただし、エンティティとして定義するためには、以下の条件を満たす必要があります。</p>

<ul>
<li>エンティティのフィールドは、プリミティブな型か、もしくはドメインのみ。</li>
<li>エンティティのフィールドは <em>public</em> のアクセス制限が必要。</li>
<li><em>public</em> として公開された、引数なしのコンストラクタが存在すること。</li>
</ul>

<p>以下はプリミティブ値として使用可能な型です。</p>

<ul>
<li>文字列(string)</li>
<li>整数(integer / int)</li>
<li>論理型(boolean / bool)</li>
<li>不動小数点数(float / double)</li>
<li>タイムゾーンなし日時(DateTime)</li>
</ul>

<p>フィールドの型は、ドキュメントコメントで指定します。指定がない場合、 <em>string</em> であると仮定します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">class</span> <span class="nc">Todo</span> <span class="p">{</span>
</span><span class='line'>  <span class="sd">/**</span>
</span><span class='line'><span class="sd">  * @var integer</span>
</span><span class='line'><span class="sd">  */</span>
</span><span class='line'>  <span class="k">public</span> <span class="nv">$id</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="sd">/**</span>
</span><span class='line'><span class="sd">  * @var string</span>
</span><span class='line'><span class="sd">  */</span>
</span><span class='line'>  <span class="k">public</span> <span class="nv">$todo</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="sd">/**</span>
</span><span class='line'><span class="sd">  * @var DateTime</span>
</span><span class='line'><span class="sd">  */</span>
</span><span class='line'>  <span class="k">public</span> <span class="nv">$createdAt</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="sd">/**</span>
</span><span class='line'><span class="sd">  * @var Hidden</span>
</span><span class='line'><span class="sd">  *</span>
</span><span class='line'><span class="sd">  * Hiddenというドメインが定義されているとする</span>
</span><span class='line'><span class="sd">  */</span>
</span><span class='line'>  <span class="k">public</span> <span class="nv">$hidden</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上の例で、コンストラクタを定義していないですが、その場合デフォルトコンストラクタが自動的に用意されるため、問題ないです。</p>

<h3>エンティティフィールドの別名</h3>

<p>エンティティをDAOのパラメータや、結果セットの詰め替え先として用いることができます。</p>

<p>しかし、必ずしも、パラメータ名や結果セットの列名と一致させることができるとは限りません。</p>

<p>そのために、エンティティのフィールドに対して別名を設定することができます。</p>

<p>別名の設定は、ドメイン同様 <strong>@Omelet\Annotation\Column</strong> アノテーションを使用します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">use</span> <span class="nx">Omelet\Annotation\Column</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Todo</span> <span class="p">{</span>
</span><span class='line'>  <span class="sd">/**</span>
</span><span class='line'><span class="sd">  * @Column(alias=&quot;todo_id&quot;) </span>
</span><span class='line'><span class="sd">  *</span>
</span><span class='line'><span class="sd">  * @var integer</span>
</span><span class='line'><span class="sd">  */</span>
</span><span class='line'>  <span class="k">public</span> <span class="nv">$id</span><span class="p">;</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3>エンティティフィールドの規定値</h3>

<p><strong>@Column</strong> アノテーションは、結果セットに該当の列が存在しない時に適用される規定値を指定することができます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Column(default=&quot;nothing&quot;)</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @var string</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">public</span> <span class="nv">$todo</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<ul>
<li>現在クラスのフィールドに定義された規定値は無視しています<br></li>
</ul>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Column(alias=&quot;some_val&quot;) </span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @var integer</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">public</span> <span class="nv">$someValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 結果セットに列がない場合でも、この値は使用されない</span>
</span></code></pre></td></tr></table></div></figure>

<h3>ドメインの関数従属値の指定</h3>

<p>結果セットの値をエンティティに詰め込む際、フィールドにドメインが存在し、そのドメインが関数従属の値を受け入れる場合、
<strong>@Column</strong> アノテーションで、その列名を指定することができます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Column(alias=&quot;edit_user_id&quot;, optFields={&quot;edit_user_name&quot;, &quot;edit_user_initial_name&quot;})</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @var Editor</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * Editorには関数従属としてname, short_nameがあるとする</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'> <span class="k">public</span> <span class="nv">$editor</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p><strong>@Column</strong> の　<em>optFields</em> に宣言した順に、ドメインのコンストラクタに渡されることに注意してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Omelet Reference(Draft) 3]]></title>
    <link href="http://ritalin.github.io/2015/05-31/omelet-reference-draft-3/"/>
    <updated>2015-05-31T23:58:43+09:00</updated>
    <id>http://ritalin.github.io/2015/05-31/omelet-reference-draft-3</id>
    <content type="html"><![CDATA[<h2>DAO (Data Access Object)</h2>

<p>データベースにアクセスし、結果を返すための窓口となるインターフェースです。</p>

<h3>メソッドアノテーション</h3>

<p>インターフェースの各メソッドは、問い合わせ／コマンドに応じて、以下のアノテーションのうちの一つを指定します</p>

<ul>
<li>@Select

<ul>
<li>問い合わせ</li>
</ul></li>
<li>@Insert 

<ul>
<li>レコード追加</li>
</ul></li>
<li>@Update

<ul>
<li>レコード更新</li>
</ul></li>
<li>@Delete

<ul>
<li>レコード削除</li>
</ul></li>
</ul>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">use</span> <span class="nx">Omelet\Annotation\Select</span><span class="p">;</span>
</span><span class='line'><span class="k">use</span> <span class="nx">Omelet\Annotation\Insert</span><span class="p">;</span>
</span><span class='line'><span class="k">use</span> <span class="nx">Omelet\Annotation\Update</span><span class="p">;</span>
</span><span class='line'><span class="k">use</span> <span class="nx">Omelet\Annotation\Delete</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">interface</span> <span class="nx">TodoDao</span> <span class="p">{</span>
</span><span class='line'>  <span class="sd">/**</span>
</span><span class='line'><span class="sd">  * @Select</span>
</span><span class='line'><span class="sd">  */</span>
</span><span class='line'>  <span class="k">function</span> <span class="nf">selectAll</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="sd">/**</span>
</span><span class='line'><span class="sd">  * @Insert</span>
</span><span class='line'><span class="sd">  */</span>
</span><span class='line'>  <span class="k">function</span> <span class="nf">insert</span><span class="p">(</span><span class="k">array</span> <span class="nv">$values</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="sd">/**</span>
</span><span class='line'><span class="sd">  * @Update</span>
</span><span class='line'><span class="sd">  */</span>
</span><span class='line'>  <span class="k">function</span> <span class="nf">update</span><span class="p">(</span><span class="k">array</span> <span class="nv">$values</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="sd">/**</span>
</span><span class='line'><span class="sd">  * @Delete</span>
</span><span class='line'><span class="sd">  */</span>
</span><span class='line'>  <span class="k">function</span> <span class="nf">delete</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3>パラメータ</h3>

<p>引数をもつメソッドを定義することで、SQLのパラメータとして提供することができます。</p>

<p>また、タイプヒンティングまたは <em>@param</em> ドキュメントコメントを示すことで、パラメータを適切に型変換します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Select</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @param boolean unfinished</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">find</span><span class="p">(</span><span class="nv">$unfinished</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>上の例は、bool型として引数を処理します</p>

<p>タイプヒンティングまたは <em>@param</em> ドキュメントコメントがない場合、引数を文字列として処理することに注意してください。</p>

<p>例えば、以下のメソッド定義において</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Select</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">findByDateBetween</span><span class="p">(</span><span class="nv">$from</span><span class="p">,</span> <span class="nv">$to</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p><em>$from</em> と <em>$to</em> は、 <strong>\Doctrine\DBAL\Types\Type::STRING</strong> として処理されます。</p>

<p>このタイプは、<em>\PDO::PARAM_STR</em> として、引数の値を変換せずそのままパラメータとしてバインドします。</p>

<p>もし、<em>$from</em> や <em>$to</em> が <strong>\DateTime</strong> 型の場合、SQL実行時にエラーとなるでしょう。</p>

<p>以下のように、タイプヒンティングかまたはドキュメントコメント（もしくは両方）を明示してください。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Select</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @param DateTime from</span>
</span><span class='line'><span class="sd"> * @param DateTime to</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">findByDateBetween</span><span class="p">(</span><span class="nx">\DateTime</span> <span class="nv">$from</span><span class="p">,</span> <span class="nx">\DateTime</span> <span class="nv">$to</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<h4>プリミティブ値を渡す</h4>

<p>メソッドの引数名がそのままSQLのパラメータ名となります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">todo</span>
</span><span class='line'><span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">id</span>
</span></code></pre></td></tr></table></div></figure>

<p>というSQLの場合、</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Select</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @param integer id</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">findById</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>というメソッド定義となります。</p>

<p>プリミティブとして扱える型は、</p>

<ul>
<li>文字列(string)</li>
<li>整数(integer / int)</li>
<li>論理型(boolean / bool)</li>
<li>不動小数点数(float / double)</li>
<li>タイムゾーンなし日時(DateTime)</li>
</ul>

<p>となります。</p>

<h4>連想配列を渡す</h4>

<p>{引数名}_{各要素のキー}をSQLのパラメータ名として使用します。</p>

<p>例えば、</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Insert</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @param string[]</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">insert</span><span class="p">(</span><span class="nv">$params</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>というメソッド定義があり、引数として渡される値が</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="p">[</span> <span class="s1">&#39;id&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;10&#39;</span><span class="p">,</span> <span class="s1">&#39;todo&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;abc-xyz-12345&#39;</span><span class="p">,</span> <span class="s1">&#39;updated_at&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;2015-05-30&#39;</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>

<p>の場合、</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">insert</span> <span class="k">into</span> <span class="n">todo</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">todo</span><span class="p">,</span> <span class="n">updateAt</span><span class="p">)</span>
</span><span class='line'><span class="k">values</span> <span class="p">(:</span><span class="n">params_id</span><span class="p">,</span> <span class="p">:</span><span class="n">params_todo</span><span class="p">,</span> <span class="p">:</span><span class="n">params_updated_at</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>という、SQLを用意します。</p>

<p>引数として、配列を渡す場合、すべての要素はドキュメントコメントに従った同じ型をもつこととなります。</p>

<p>上の例のように、パラメータに文字列として日付を渡す場合、
例えばSQLiteでは日付のフォーマットが異なれば正しくフィルタできなくなる可能性があります。</p>

<p>従って、連想配列を使う場合は、すべての配列要素が、 <em>string[]</em> , <em>integer[]</em> , <em>DateTime[]</em> の場合に限定する方が良いでしょう。</p>

<p>複数の型が混在する場合、後述のエンティティに詰め込むことを推奨します。</p>

<h4>ドメインを渡す</h4>

<p>メソッドの引数名がそのままSQLのパラメータ名となります。</p>

<p>ドメインは、 <strong>\Omelet\Domain\CustomDomain</strong> の派生クラスを指します。</p>

<p>ドメイン定義時に指定された <strong>\Doctrine\DBAL\Types\Type</strong> の型定数を元に、保持するドメイン値を適切に整形してSQLのパラメータとして渡します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Select</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @param PrimaryKey id</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">findById</span><span class="p">(</span><span class="nx">PrimaryKey</span> <span class="nv">$id</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>と、メソッドを定義する場合、SQLは</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">todo</span>
</span><span class='line'><span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">id</span>
</span></code></pre></td></tr></table></div></figure>

<p>と、なります。</p>

<h4>エンティティを渡す</h4>

<h3>結果の取得(Select)</h3>

<p>メソッドに <em>@return</em> ドキュメントコメントが明示されている場合、その型での結果セットの返却を行います。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Select</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @param integer id</span>
</span><span class='line'><span class="sd"> * @return DateTime</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">getPublishedDateById</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>上の例では、結果から <strong>DateTime</strong> 型のオブジェクトを生成して返します。</p>

<p>メソッドに <em>@return</em> ドキュメントコメントが明示されていない場合、行の配列として返します。
行は列名をキーとする連想配列で、その値の型はすべて文字列です。</p>

<h4>プリミティブ値として取得</h4>

<p>結果をプリミティブ値として返却します。</p>

<p>プリミティブとして扱える型は、引数と同様</p>

<ul>
<li>文字列(string)</li>
<li>整数(integer / int)</li>
<li>論理型(boolean / bool)</li>
<li>不動小数点数(float / double)</li>
<li>タイムゾーンなし日時(DateTime)</li>
</ul>

<p>です。</p>

<p>SQLの実行結果が複数行となる場合、その先頭行、先頭列の値を返します。
これは適切にソートされていないと、受け取る結果が安定しないということを意味しています。</p>

<h4>プリミティブ値の配列として取得</h4>

<p>メソッドのドキュメントコメントがプリミティブな型の配列の場合、結果をプリミティブ値として返却します。</p>

<p>PhpDocumenterの仕様に従い、配列は型名の後ろに <strong>[ ]</strong> を付与します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Select</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @return DateTime[]</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">listPublishedDateAll</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>

<h4>ドメインとして取得</h4>

<p>結果をドメインとして返却します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Select</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @param PrimaryKey id</span>
</span><span class='line'><span class="sd"> * @return Hidden</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">hidden</span><span class="p">(</span><span class="nx">PrimaryKey</span> <span class="nv">$id</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>結果セットの列名に、ドメインのコンストラクタの引数名、もしくは別名が存在する場合、ドメインとしてインスタンス化して返します。</p>

<p>一致する列名が存在しない場合でも、ドメインをインスタンス化ことに注意してください。</p>

<p>また、ドメイン定義として、関数従属の要素を持ち、その名前、または別名が結果セットに存在する場合、関数従属の値付きでドメインをインスタンス化します。</p>

<p>プリミティブ値として取得の時と同様、SQLの実行結果が複数行となる場合、先頭行の内容からドメインの構築を試みます。</p>

<h4>ドメインの配列として取得</h4>

<p>結果をドメインの配列として返却します。</p>

<p>各行のドメインの構築は、ドメインとして取得と同様です。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Select</span>
</span><span class='line'><span class="sd"> *</span>
</span><span class='line'><span class="sd"> * @return PrimaryKey[]</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">listAllId</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>

<h4>エンティティとして取得</h4>

<h4>エンティティの配列として取得</h4>

<h3>結果の取得(Insert, Update, Delete)</h3>

<p>現在の仕様では、作用されたレコード数を返します。</p>

<h3>クラスアノテーション</h3>

<p>DAOインターフェースには、専用のアノテーションとして、 <strong>@Dao</strong> が用意されています。</p>

<p>このアノテーションは以下のパラメータを持っています。</p>

<ul>
<li>route</li>
</ul>

<p>通常、SQLはインターフェースの完全クラス名（名前空間\インターフェース名）をパスと見立てたディレクトリの中に、メソッド名と同名のSQLファイルを用意します。</p>

<p>名前空間が長くなると、SQLファイルを探し出すのが大変になります。</p>

<p><em>route</em> パラメータを指定することで、名前空間の分をショートカット、もしくは別ディレクトリにSQLを置くことができます。</p>

<p>例えば、 </p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">namespace</span> <span class="nx">Foo\Bar\Baz</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Dao(route=&quot;FBB&quot;)</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">interface</span> <span class="nx">HogeDao</span> <span class="p">{</span>
</span><span class='line'>  
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>という定義の場合、</p>

<p><em>Foo/Bar/Baz/HogeDao</em> の代わりに * FBB* を探しに行くようになります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Omelet Reference(Draft) 2]]></title>
    <link href="http://ritalin.github.io/2015/05-31/omelet-reference-draft-2/"/>
    <updated>2015-05-31T18:41:16+09:00</updated>
    <id>http://ritalin.github.io/2015/05-31/omelet-reference-draft-2</id>
    <content type="html"><![CDATA[<h2>ドメイン</h2>

<p>ドメインは、リレーショナルモデルがらくる概念で、対象の文脈においてこれ以上分解できない値の集合に対して名前をつけたものです。</p>

<p>ドメインは、一例として、郵便番号、氏名、日時などが挙げられます。</p>

<p>今挙げた例を思い浮かべてみればわかるように、別の文脈ではさらに分解する場合もあるでしょう（日時 -&gt; 日付 + 時刻)。</p>

<h2>ドメイン型の定義</h2>

<p>Omeletにおいては、その値が属する型であり、 <strong>\Omelet\Domain\CustomDomain</strong> の派生クラスを指します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="c1">// 郵便番号の場合</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Zip</span> <span class="k">extends</span> <span class="nx">\Omelet\Domain\CustomDomain</span> <span class="p">{</span>
</span><span class='line'>  
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p><strong>\Omelet\Domain\CustomDomain</strong> クラスのコンストラクタは、<em>protected</em> として定義されています。
そのため、派生クラスのコンストラクタでは、明示的に親クラスのコンストラクタを読んであげる必要があります。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">public</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">(</span><span class="nv">$zip</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">parent</span><span class="o">::</span><span class="na">__construct</span><span class="p">(</span><span class="nx">\Doctrine\DBAL\Types\Type</span><span class="o">::</span><span class="na">STRING</span><span class="p">,</span> <span class="nv">$zip</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>親クラスのコンストラクタの引数は、以下の通りです</p>

<ul>
<li>$type

<ul>
<li><strong>\Doctrine\DBAL\Types\Type</strong> で定義されている、利用可能な型定数のいずれかを指定。

<ul>
<li>指定可能な定数は、<a href="http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/types.html">DBALのドキュメント</a>参照。</li>
</ul></li>
</ul></li>
<li>$value

<ul>
<li>派生先のコンストラクタに渡された値。</li>
</ul></li>
</ul>

<p>保持する値の取得は、 <strong>getValue()</strong> を使用します。</p>

<h3>関数従属の付与</h3>

<p>ドメインは本来、一つの値をパッケージングしたものとなりますが、 Omeletでは、例えば郵便番号に対して住所のような関数従属となる値を保持できるようにしています。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">public</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">(</span><span class="nv">$zip</span><span class="p">,</span> <span class="nv">$address</span> <span class="o">=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">parent</span><span class="o">::</span><span class="na">__construct</span><span class="p">(</span><span class="nx">\Doctrine\DBAL\Types\Type</span><span class="o">::</span><span class="na">STRING</span><span class="p">,</span> <span class="nv">$zip</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;address&#39;</span> <span class="o">=&gt;</span> <span class="nv">$address</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>コンストラクタの第二引数以降に、保持させたい値を割り当てるようにします。</p>

<p>親クラスのコンストラクタの第３引数に、これらの値を連想配列として渡します。</p>

<p>付与した値の取り出しは、 <strong>getOptValue(連想配列のキー名)</strong> を使用します。しかしこの関数はあえて <em>protected</em> として定義しています。
派生クラスで <em>public</em> として再定義するよりはむしろ、値ごとの取得関数を定義することを期待しているためです。</p>

<p>関数名は、後述の結果セットの変換の都合上、<em>引数名()</em> または、 <em>get引数名()</em> としてください。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">function</span> <span class="nf">getAddress</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getOptValue</span><span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3>結果セットからの変換</h3>

<p>Omeletは、SQLの問い合わせにより得られた結果セットから、ドメインを作成させることができます。</p>

<p>通常、結果セットは連想配列として得られますが、ドメインのコンストラクラの引数名を連想配列のキーとして、値を取り出し、ドメインインスタンスの生成を自動的に行います。</p>

<h4>別名の指定</h4>

<p>コンストラクタの引数名と、結果セットのキー（カラム名）は必ずしも一致するとは限りません。</p>

<p>SQLの記述で合わせてしまうのもいいですが、Omeletでは、ドメインのクラス定義として別名を与えることができます。</p>

<p>ドメイン自身が保持する値については、コンストラクタにアノテーションコメント、 <strong>@Column (\Omelet\Annotation\Column)</strong> を付与します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">use</span> <span class="nx">Omelet\Annotation\Column</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="err">....</span>
</span><span class='line'>
</span><span class='line'><span class="x">/**</span>
</span><span class='line'><span class="x"> * @Column(alias=&quot;zip_number&quot;)</span>
</span><span class='line'><span class="x"> */</span>
</span><span class='line'><span class="x">public function __construct($zip, $address = null) {</span>
</span></code></pre></td></tr></table></div></figure>

<p><strong>Column</strong> の　<em>alias</em> プロパティに別名を指定します。</p>

<p>関数従属の値については、前の節で説明した取得関数に、 <strong>@Column</strong> アノテーションを付与します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @Column(alias=&quot;adrs&quot;)</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">function</span> <span class="nf">getAddress</span><span class="p">()</span> <span class="p">{</span>
</span></code></pre></td></tr></table></div></figure>

<p>また、コンストラクタの引数名や別名は、設定の <em>returnCaseSensor</em> の影響を受けます。</p>

<p>引数や別名はキャメルケースであるが、設定を大文字のスネークケースにした場合、名称の変換が行われます。</p>

<h4>結果セット値の型変換</h4>

<p>結果セットはすべて文字列として返されます。別の型で保持したい場合型変換が必要となります。例えば日時を <em>DateTime</em> で保持するなど。</p>

<p>この型は、コンストラクタのタイプヒントの他に、コンストラクタのドキュメントコメントからの取得を試みます。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">/**</span>
<span class="x"> * @Column(alias=&quot;zip_number&quot;)</span>
<span class="x"> *</span>
<span class="x"> * @param string zip</span>
<span class="x"> * @param string address</span>
<span class="x"> * @param integer streetNumber </span>
<span class="x"> */</span>
<span class="x">public function __construct($zip, $address = null, $streetNumber = null) {</span>
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Omelet Reference(Draft) 1]]></title>
    <link href="http://ritalin.github.io/2015/05-30/omelet-reference-draft-1/"/>
    <updated>2015-05-30T22:11:39+09:00</updated>
    <id>http://ritalin.github.io/2015/05-30/omelet-reference-draft-1</id>
    <content type="html"><![CDATA[<h2>設定</h2>

<ul>
<li><strong>\Omelet\Build\Configuration</strong> クラス

<ul>
<li>データベース接続先などの、共通設定情報を格納する。</li>
</ul></li>
</ul>

<h3>プロパティ</h3>

<ul>
<li><p>daoClassPath</p>

<ul>
<li>DAO (Data Access Object)の具象実装クラスが保存されるディレクトリまでのパスを指定する。</li>
<li>文字列</li>
<li>規定値：auto_generated</li>
</ul></li>
<li><p>sqlRootDir</p>

<ul>
<li>SQLが置かれているルートのディレクトリまでのパスを指定する。</li>
<li>文字列</li>
<li>規定値：sql</li>
</ul></li>
<li><p>daoClassSuffix</p>

<ul>
<li>DAOの具象実装クラス名のサフィックスとして付与する文字列。</li>
<li>文字列</li>
<li>規定値： Impl</li>
<li>例： TodoDao -&gt; TodoDaoImpl</li>
</ul></li>
<li><p>connectionString</p>

<ul>
<li>データベースの接続情報

<ul>
<li>URL形式、またはクエリ文字列形式で指定する。</li>
<li>設定内容の詳細は、<a href="http://doctrine-dbal.readthedocs.org/en/latest/reference/configuration.html">doctrine/DABLのドキュメント</a>参照。</li>
</ul></li>
<li>文字列</li>
</ul></li>
<li><p>watchMode = &#39;Whenever&#39;;</p>

<ul>
<li>作成タイミングの指定

<ul>
<li><strong>Always</strong> , <strong>Whenever</strong> , <strong>Once</strong> のいずれかを指定する。

<ul>
<li>Always：DAOインターフェースの変更の有無に関わらず、毎回実装クラスを作成する。</li>
<li>Whenever：初回または、DAOインターフェースの内容が変更した場合のみ、実装クラスを再作成する。</li>
<li>Once：初回に一度だけ、実装クラスを作成する</li>
</ul></li>
</ul></li>
<li>文字列</li>
<li>規定値：Whenever</li>
</ul></li>
<li><p>paramCaseSensor</p>

<ul>
<li>SQLで使用するパラメータ名の命名規則</li>
<li>例えば、DAOメソッドの引数をキャメルケースで定義し、設定を <strong>UpperSnake</strong> にした場合、アルファベット大文字のスネークケースに変換する。

<ul>
<li><strong>LowerSnake</strong> , <strong>UpperSnake</strong> , <strong>LowerCamel</strong> , <strong>UpperCamel</strong> のいずれかを指定する。

<ul>
<li>LowerSnake

<ul>
<li>アルファベット小文字で単語間を <strong>アンダースコア文字(_)</strong> でつなぐ。</li>
</ul></li>
<li>UpperSnake

<ul>
<li>アルファベット大文字で単語間を <strong>アンダースコア文字(_)</strong> でつなぐ。</li>
</ul></li>
<li>LowerCamel

<ul>
<li>先頭の単語を除いて、２番目以降の単語の１文字目を大文字にしてそのままつなげる。</li>
<li>元の規則がスネークケースの場合、アンダースコア文字は取り除かれることに注意。</li>
</ul></li>
<li>UpperCamel

<ul>
<li>単語の１文字目を大文字にしてそのままつなげる。</li>
<li>元の規則がスネークケースの場合、アンダースコア文字は取り除かれることに注意。</li>
</ul></li>
</ul></li>
</ul></li>
<li>文字列</li>
<li>規定値： LowerSnake</li>
</ul></li>
<li><p>returnCaseSensor = &#39;LowerSnake&#39;;</p>

<ul>
<li>クエリ実行により得られる結果セットの列名の命名規則</li>
<li>結果をオブジェクト(エンティティクラス)やドメインに詰め替える際、命名規則の変換が適用される。

<ul>
<li><strong>LowerSnake</strong> , <strong>UpperSnake</strong> , <strong>LowerCamel</strong> , <strong>UpperCamel</strong> のいずれかを指定する。</li>
<li>それぞれの値の意味は、 <strong>paramCaseSensor</strong> と同じ</li>
</ul></li>
<li>文字列</li>
<li>規定値： LowerSnake</li>
</ul></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ Index]]></title>
    <link href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-index/"/>
    <updated>2015-03-29T21:28:40+09:00</updated>
    <id>http://ritalin.github.io/2015/03-29/restful-web-api-memo-index</id>
    <content type="html"><![CDATA[<h2>Restful Web APIs - Index</h2>

<ul>
<li><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-01/">Chapter 1. Surfing the Web</a></li>
<li><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-02/">Chapter 2. A Simple API</a></li>
<li><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-03/">Chapter 3. Resources and Representations</a></li>
<li><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-04/">Chapter 4. Hypermedia</a></li>
<li><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-05/">Chapter 5. Domain-Specific Designs</a></li>
<li><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-06/">Chapter 6. The Collection Pattern</a></li>
<li><a href="http://ritalin.github.io/2015/03-09/restful-web-api-memo-07/">Chapter 7. Pure-Hypermedia Designs</a></li>
<li><a href="http://ritalin.github.io/2015/03-11/restful-web-api-memo-08/">Chapter 8. Profiles</a></li>
<li><a href="2015/03-19/restful-web-api-memo-09/">Chapter 9. The Design Procedure</a></li>
<li><a href="http://ritalin.github.io/2015/03-22/restful-web-api-memo-10/">Chapter 10. The Hypermedia Zoo (Part.1)</a></li>
<li><a href="http://ritalin.github.io/2015/03-22/restful-web-api-memo-11/">Chapter 10. The Hypermedia Zoo (Part.2)</a></li>
<li><a href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-15/">Chapter 11. HTTP for APIs</a></li>
<li><a href="http://ritalin.github.io/2015/03-27/restful-web-api-memo-12/">Chapter 12. Resource Description and Linked Data</a></li>
<li><a href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-13/">Chapter 13. CoAP: REST for Embedded Systems</a></li>
<li><a href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-14/">Appendix An API Designer’s Guide to the Fielding Dissertation</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(14)]]></title>
    <link href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-14/"/>
    <updated>2015-03-29T21:25:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-29/restful-web-api-memo-14</id>
    <content type="html"><![CDATA[<h2>Appendix C. An API Designer&#39;s Guide to the Fielding Dissertation</h2>

<h3>アーキテクチャ特性</h3>

<ul>
<li>Low Entry-barrier

<ul>
<li>FTPやTelnetのようにたくさんのコマンドを駆使する必要がない</li>
<li>使い方を学ぶのが容易で、サイト構築も容易</li>
</ul></li>
<li>Extensibility</li>
<li>Distributed Hypermedia</li>
<li>Internet-scale</li>
</ul>

<h3>アーキテクチャ制約</h3>

<ul>
<li>Client-Servet

<ul>
<li>webにおける通信は1:1</li>
</ul></li>
<li>Statelessness

<ul>
<li>クライアントがリクエストを作らなければ、サーバーはクライアントの存在を知らない</li>
</ul></li>
<li>Caching

<ul>
<li>キャッシュから前回のレスポンスを再利用することで、通信を抑える</li>
</ul></li>
<li>Uniform Interface

<ul>
<li>リソースの一意化

<ul>
<li>リソースは安定したURIで一意化される</li>
</ul></li>
<li>表現を通したリソースの操作

<ul>
<li>サーバーはクライアントに表現を送ることで、リソース状態を記述</li>
<li>クライアントはサーバーにアプリケーション状態を送ることでリソース状態を操作する</li>
</ul></li>
<li>自己記述メッセージ

<ul>
<li>すべての情報は、リクエストやレスポンスがリンクを介してメッセージ自身に含まれることを理解する必要がある</li>
</ul></li>
<li>ハイパーメディア制約

<ul>
<li>サーバーはハイパーメディアメニューを送ることでアプリケーション状態を操作する

<ul>
<li>メニューとは、クライアントが自由に操作できるオプション</li>
</ul></li>
</ul></li>
</ul></li>
<li>Layered System

<ul>
<li>クライアントとサーバーの間に入れられたプロキシは不可視</li>
</ul></li>
<li>Code on Demand

<ul>
<li>サーバーはデータと一緒に実行コードを送ることができる</li>
<li>クライアントのリクエストで、自動的に配置される</li>
<li>コードの変更でも自動的に再配置される</li>
</ul></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(13)]]></title>
    <link href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-13/"/>
    <updated>2015-03-29T21:12:33+09:00</updated>
    <id>http://ritalin.github.io/2015/03-29/restful-web-api-memo-13</id>
    <content type="html"><![CDATA[<h2>Chapter 13. CpAP: REST for Embedded Systems</h2>

<ul>
<li>CoAP

<ul>
<li>IOT(Internet of Things)のような低出力組み込み環境用</li>
<li>HTTPの考えを踏襲</li>
<li>ハイパーメディア駆動のRESTful APIが使用可能</li>
</ul></li>
</ul>

<!-- more -->

<h3>CoAP(Constraintrd Application Protocol)</h3>

<ul>
<li>低出力組込み機器むけプロトコル</li>
<li>UDPベース</li>
<li>メソッド

<ul>
<li>GET/POST/PUT/DELETE

<ul>
<li>安全性と冪等性はhttpと同じ</li>
</ul></li>
</ul></li>
<li>CONリクエスト

<ul>
<li>conformableメッセージ</li>
<li>ACKを受け取るまで送り続ける</li>
</ul></li>
<li>NON

<ul>
<li>nonconformableメッセージ</li>
<li>ACKレスポンスを要求しない</li>
</ul></li>
<li>RST

<ul>
<li>resetメッセージ</li>
<li>対象機器を再起動させたりとか</li>
</ul></li>
</ul>

<h4>リクエスト</h4>

<p>&#39;&#39;&#39;
CON [0xbc90]
GET /temperature
Token [0x71]
&#39;&#39;&#39;</p>

<ul>
<li>CON

<ul>
<li>confirmable</li>
<li>0xbc90
    * メッセージID</li>
<li>Token

<ul>
<li>すべてのレスポンスで使われる値</li>
</ul></li>
</ul></li>
</ul>

<h4>レスポンス</h4>

<p>&#39;&#39;&#39;
ACK [0xbc00]
2.05 Content
(Token 0x71)
Content-Format: text/plain ; charset=utf-8
22.5 C
&#39;&#39;&#39;</p>

<ul>
<li>ACK

<ul>
<li>受信</li>
</ul></li>
<li>2.05

<ul>
<li>ステータスコード</li>
</ul></li>
<li>Content-Format

<ul>
<li>httpのcontent-typeと同じ意味</li>
</ul></li>
<li>22.5 C

<ul>
<li>entity-bidy</li>
</ul></li>
</ul>

<h4>Delayed Response</h4>

<ul>
<li>クライアントはCON を送り、サーバーは瞬時にACKを返す</li>
<li>しばらくしサーバーは、別メッセージIDで同トークンをもつCON / NONを送る</li>
</ul>

<h4>Multicast Message</h4>

<ul>
<li>UDP multicastを用いたメッセージを一括配信をサポート</li>
<li>機器間で自律的な検出、データ交換、コラボが可能となる</li>
<li>自律的な振る舞いは、REST制約のハイパーメディアコントロールが重要</li>
</ul>

<h3>CoAE Link Format</h3>

<ul>
<li>media-type

<ul>
<li>application/link-format</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETによるナビゲーションと探索</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>RFC6690</li>
<li>全体として80Byteな1024Byteに抑えることは、他のフォーマットでは不可能</li>
<li>Http圧縮で帯域幅を抑えても、各機器のスペックでは展開できない</li>
<li>CoAPと異なりhuman-readableフォーマット</li>
</ul>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-14/">RESTful Web APIs 読書メモ(14)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[restful-web-api-memo-15]]></title>
    <link href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-15/"/>
    <updated>2015-03-29T13:42:38+09:00</updated>
    <id>http://ritalin.github.io/2015/03-29/restful-web-api-memo-15</id>
    <content type="html"><![CDATA[<h2>Chapter 11. HTTP for APIs</h2>

<ul>
<li>Web APIの技術的スタック

<ul>
<li>ハイパーメディア

<ul>
<li>次は何？に答える</li>
</ul></li>
<li>HTTP

<ul>
<li>リソースとはどのようにしてやりとりするのか？に答える</li>
</ul></li>
<li>URL 

<ul>
<li>リソースはどこにあるのか？に答える</li>
</ul></li>
</ul></li>
</ul>

<!-- more -->

<h3>HTTP仕様</h3>

<ul>
<li>RFC2616</li>
<li>41のレスポンスコードを定義

<ul>
<li>プロトコルセマンティクスの基本セットを表現する</li>
<li>400

<ul>
<li>不正なデータが送りつけられてきた場合</li>
<li>問題点をentity-bodyに示す</li>
</ul></li>
<li>付録A参照</li>
</ul></li>
<li>47のリクエスト / レスポンスヘッダを定義

<ul>
<li>プロトコルセマンティクスの基本セットを提供する</li>
<li>付録B参照</li>
</ul></li>
<li>表現の選択

<ul>
<li>一つのリソースは多くの表現をもつ</li>
<li>表現は異なるフォーマットをもつ</li>
<li>コンテントネゴシエーション

<ul>
<li>Accept-*のセットが提供されている</li>
<li>Accept

<ul>
<li>media-typeの選択</li>
</ul></li>
<li>Accept-Language

<ul>
<li>言語の選択</li>
</ul></li>
<li>対応する表現がない場合、406(Not Acceptable)を返す</li>
</ul></li>
<li>プロファイルネゴシエーション

<ul>
<li>media-typeがprofileパラメータを持つ場合に利用可能</li>
<li>コンテントネゴシエーションと合わせて使用する</li>
</ul></li>
<li>ハイパーメディアメニュー

<ul>
<li>利用可能な表現の一覧を返し、その中からクライアントに選択させる</li>
<li>300(multiple Choices)を返す

<ul>
<li>entity-bodyに選択可能なリンクを提示する</li>
</ul></li>
<li>htmlのaタグ、linkタグはハイパーメディアメニューきのうを持つ

<ul>
<li>type属性

<ul>
<li>media-typeを指定する</li>
</ul></li>
<li>hreflang

<ul>
<li>言語を指定する</li>
</ul></li>
</ul></li>
</ul></li>
<li>正規化URL

<ul>
<li>リソースが一つ以上のURLを持つ場合、代表のURLを明示すること</li>
<li>以下のいずれかを使用

<ul>
<li>Content-Location</li>
<li>canonicalリレーション</li>
</ul></li>
</ul></li>
<li>キャッシュ(Cache-Control)

<ul>
<li>リクエスト

<ul>
<li>キャッシュを使うかどうかの指示</li>
</ul></li>
<li>レスポンス

<ul>
<li>前回のリクエストから変更があったかどうかを伝える</li>
<li>API実装を変更する場合、マイグレーションのために適切にmax-ageを設定すべき</li>
</ul></li>
</ul></li>
<li>Conditional Request
    * リソース状態が変更する場合、適切にmax-ageを決定することは難しい
    * Last-Modified
        * レスポンスで最終更新日時を返す
        * 次回リクエストでIf-Modified-Sinceヘッダに埋め込む
            * リソース状態が変更していない場合、304(Not Modified)を返す
            * 動的、静的コンテンツにかかわらずサーバーリソースを節約できる
            * 次回リクエストのために保存しておく必要がある
    * ETag
        * リソース状態が変更した時のみに変更される文字列
            * リソースをハッシュ化して生成
            * Last-Mofifiedのように、別途保存しておく必要がなくなる
        * 次回リクエストでIf-None-Matchに、ETagの文字列を指定する
        * リソース状態に変更がなければ304(Not Modified)を返す</li>
<li>LBYL(Look Before You Leap) Request

<ul>
<li>entity-bodyのないPUTリクエストを送る</li>
<li>PUTが受け入れ可能な場合、100(Continue)を返す

<ul>
<li>改めて、entity-body付きでPUTリクエストを送る</li>
</ul></li>
<li>PUTが棄却された場合、417(Expection Failed)が返される</li>
</ul></li>
<li>圧縮

<ul>
<li>リクエストヘッダにAccept-Encodingを含める

<ul>
<li>たいていgzip</li>
</ul></li>
<li>サーバーが圧縮アルゴリズムをサポートしていれば、圧縮

<ul>
<li>レスポンスヘッダに同じAccept-Encodingを含める</li>
</ul></li>
</ul></li>
<li>Partial GET

<ul>
<li>表現のサブセットを取得する方法</li>
<li>主にダウンロードを再開する目的でもちいられる</li>
<li>リクエストヘッダに開始位置をRangeに指定

<ul>
<li>単位はkB</li>
</ul></li>
<li>レスポンスコードは206(Partial Content)</li>
<li>レスポンスヘッダにContent-Rangeを含める</li>
<li>コレクションの一部の取得に使えそうだが、非標準

<ul>
<li>自身のプロトコルセマンティクスを検討すべき</li>
<li>prevやnextなどのリンクリレーション</li>
</ul></li>
</ul></li>
<li>HTTPパイプライン

<ul>
<li>クライアントは一度に複数のリクエストを送る</li>
<li>サーバーは受け取った順にレスポンスを返す</li>
<li>GETのみでパイプライン化が望ましい

<ul>
<li>ほかのメソッドとの組み合わせは、途中で切断されてもロールバックできないため</li>
</ul></li>
<li>Web APIとは相性が悪い

<ul>
<li>たいていAPIは、ワークフローとなるため</li>
</ul></li>
</ul></li>
<li>Lost Update問題点をの回避

<ul>
<li>不安定なメソッド(PUT/PATCH)を同時に使われると、後勝ちとなる</li>
<li>先勝ちにしたければConditional Requestを使う

<ul>
<li>Last-Modified

<ul>
<li>If-Unmodifid-Since</li>
</ul></li>
<li>ETag

<ul>
<li>If-None-Match</li>
</ul></li>
</ul></li>
<li>変更されていれば、412(Precondition Failed)が返される</li>
<li>不安定なメソッドには、常にConditional Requestが望ましい

<ul>
<li>利用されていなければ、428(Precondition Required)を返す姿勢で</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h3>HTTP認証</h3>

<ul>
<li>Basic認証

<ul>
<li>RFC2617</li>
<li>ユーザー名/パスワードの組で認証</li>
<li>あまりセキュアではない

<ul>
<li>クレデンシャルはBase64エンコードされるだけ</li>
<li>TLSに乗せれば、盗聴を防げるので、多少セキュアになる</li>
</ul></li>
</ul></li>
<li>Digest認証

<ul>
<li>RFC2617</li>
</ul></li>
<li>OAuth 1.0

<ul>
<li>RFC5849</li>
<li>クライアントごとに別々のクレデンシャルを与える</li>
<li>利用者は、トークンクレデンシャルを利用停止にすることで、スパム被害を最小化できる</li>
<li>OAuthプロバイダは、クライアントクレデンシャル(consumer_key)を停止することで、スパム被害を最小化できる</li>
</ul></li>
<li>OAuth 2.0</li>
<li>RFC6749</li>
<li>4つのアクセストークン取得プロセス

<ul>
<li>Authrization Code

<ul>
<li>OAuth 1.0の方法</li>
</ul></li>
<li>Implicit Gant</li>
<li>Resource Owner Password Credential

<ul>
<li>モバイルクライアント向け</li>
</ul></li>
<li>Client Credentials</li>
</ul></li>
</ul>

<h3>HTTP拡張</h3>

<ul>
<li>WebDav</li>
<li>HTTP/2</li>
<li>CoAP</li>
<li>PATCHメソッド

<ul>
<li>RFC5789</li>
<li>安全ではないがベキ等でない</li>
<li>差分更新を可能とする</li>
<li>パッチフォーマット

<ul>
<li>application/json-patch

<ul>
<li>RFC6902</li>
</ul></li>
<li>application/xml-patch+xml

<ul>
<li>RFC5261</li>
</ul></li>
</ul></li>
</ul></li>
<li>LINK/UNLINKメソッド

<ul>
<li>RFC2616(破棄)

<ul>
<li>使い道が見出せなかったため</li>
</ul></li>
<li>安全ではないが冪等</li>
<li>2つのリソースかんを接続(切断) するメソッド</li>
<li>リンク先は、LINKヘッダで指定する</li>
</ul></li>
</ul>

<h3>WebDav</h3>

<ul>
<li>RFC4918</li>
<li>HTTPベースのファイルシステム</li>
<li>利用例

<ul>
<li>MS SharePoint</li>
<li>Subversion</li>
</ul></li>
<li>メソッド

<ul>
<li>MKCOL

<ul>
<li>コレクションの新規作成</li>
</ul></li>
<li>PROPATCH/PROPFIND

<ul>
<li>リソースにキーワードをつけることで、検索しやすくする</li>
</ul></li>
<li>LOCK/UNZlOCK

<ul>
<li>リソースのロック</li>
<li>同時アクセスを防ぐ目的</li>
<li>すでにロックされてれば、408(Conflict)を返す

<ul>
<li>423(Locked)も定義されてるが利用は推奨されていない模様</li>
</ul></li>
</ul></li>
<li>MOVE/COPY

<ul>
<li>リソースの移動またはコピー</li>
<li>目的地は、Destinationヘッダで指定する</li>
</ul></li>
</ul></li>
</ul>

<h3>Http/2</h3>

<ul>
<li>SPDYベースにした進化版</li>
<li>ヘッダ圧縮</li>
<li>同時リクエスト発行</li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-12/">RESTful Web APIs 読書メモ(12)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(12)]]></title>
    <link href="http://ritalin.github.io/2015/03-27/restful-web-api-memo-12/"/>
    <updated>2015-03-27T22:12:55+09:00</updated>
    <id>http://ritalin.github.io/2015/03-27/restful-web-api-memo-12</id>
    <content type="html"><![CDATA[<h2>Chapter 12. Resource Description and Linked Data</h2>

<ul>
<li>ハイパーメディアフォーマット

<ul>
<li>表現戦略と記述戦略の両方を有する</li>
</ul></li>
</ul>

<!-- more -->

<ul>
<li>表現戦略(Presentation Strategy)

<ul>
<li>リソースのURLにGETリクエストを送り、リソースの表現を受け取ること</li>
</ul></li>
<li>記述戦略(Description Strategy)

<ul>
<li>リソースAがリソースBのURLを知っていること</li>
<li>利点

<ul>
<li>リソースBのなにかを調べるために使用できる</li>
<li>非ハイパーメディアフォーマットにアプリケーションセマンティクスを提供する

<ul>
<li>JSON-LD,&#8230;</li>
</ul></li>
<li>表現を持たないリソースを扱える

<ul>
<li>ISBN,&#8230;</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h3>RDF(Resource Description Framework)</h3>

<ul>
<li>media-type

<ul>
<li>application/rdf+xml</li>
<li>text/turtle</li>
<li>&#8230;..</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETによるナビゲーション</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>なし</li>
<li>アプリケーションセマンティクスのためのフレームワークという立ち位置
*URIにアプリケーションセマンティクスの意味づけ</li>
</ul></li>
<li>純粋な記述戦略

<ul>
<li>すべてのREST制約を満たせていない</li>
</ul></li>
<li>プロパティ

<ul>
<li>rdf:Description/@about

<ul>
<li>リソースのURIを指定</li>
<li>URLをURIとして扱う</li>
</ul></li>
<li>rdf:type

<ul>
<li>リソースタイプ</li>
<li>リソースはリソースタイプURIで分類できる

<ul>
<li>ジャンル、種別、&#8230;</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h3>RDF Schema</h3>

<ul>
<li>リソースタイプについてのプロファイル</li>
<li>低レイヤーのアプリケーションセマンティクス

<ul>
<li>human-readable

<ul>
<li>rdfs:label</li>
<li>rdfs:comment</li>
</ul></li>
<li>machine-readable

<ul>
<li>rdfs:subclassOf

<ul>
<li>ベースとなるコンセプト</li>
</ul></li>
<li>rdfs:domain

<ul>
<li>リレーションの親</li>
<li>入力引数</li>
</ul></li>
<li>rdfs:range

<ul>
<li>リレーションのリンク先</li>
<li>戻り値</li>
<li>このリソースタイプにrfds:domsin突っ込むと、rdfs:rangeとして得られる<br></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h3>Linked Data</h3>

<ul>
<li>RDFはRESTfulになれない

<ul>
<li>URLの代わりにURIを使用するため</li>
<li>URIはただの識別子

<ul>
<li>そこからリソース表現が取得できることは保証していない</li>
</ul></li>
<li>machine-readableなアプリケーションセマンティクスを記述するのであればALPSを上回る強力さ</li>
</ul></li>
<li>Linked Data = RDF + 表現戦略</li>
<li>Link Data原則

<ol>
<li>URIはリソースの名前

<ul>
<li>= addressability原則</li>
</ul></li>
<li>URIにリクエストを投げれる

<ul>
<li>URIとして、urnは使用しない</li>
</ul></li>
<li>URIからリソース表現が取得できる</li>
<li>ほかのURIへのリンクを含める

<ul>
<li>= connectednessの原則</li>
<li>そのURIのリソース表現が取得可能とする</li>
</ul></li>
</ol></li>
</ul>

<h3>Linked Dataフォーマット</h3>

<h4>JSON-LD</h4>

<ul>
<li>media-type

<ul>
<li>application/ld+json</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETによるナビゲーション</li>
</ul></li>
<li><p>アプリケーションセマンティクス</p>

<ul>
<li>自己記述式</li>
</ul></li>
<li><p>Linked Data APIを書くなら、断然RDFよりJSON-LDオススメ</p></li>
<li><p>利用方法</p>

<ul>
<li>別リソースとしてLINKヘッダでJSON-LDを指定</li>
<li>直接リソースのメタデータとして埋め込む</li>
</ul></li>
</ul>

<h4>Hydra</h4>

<ul>
<li>media-type

<ul>
<li>application/ld+json</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>JSON-LD + 任意のHTTPメソッド</li>
<li>supprtedOperationでJSONオブジェクトとして指定</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>コレクションパターンを使って自己記述</li>
</ul></li>
</ul>

<h4>XRD/JRD</h4>

<ul>
<li>media-type

<ul>
<li>application/xrd+xml</li>
<li>application/jrd+json</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETによるナビゲーション</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>なし</li>
</ul></li>
<li>RFC6415(XRD)</li>
<li>propertyタグ、linkタグでアプリケーションセマンティクスを記述

<ul>
<li>URIを指定するため、存在するかどうかは保証されない</li>
</ul></li>
</ul>

<h4>Web Host Metadata Document</h4>

<ul>
<li>media-type

<ul>
<li>application/xrd+xml</li>
<li>application/jrd+json</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETによるナビゲーション</li>
<li>GETによる限定的なルックアップ

<ul>
<li>linkタグのtemplate属性にURI Templateとして埋め込む</li>
<li>urnであったとしてもリソース表現を取得できる</li>
</ul></li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>なし</li>
</ul></li>
<li>RFC6415</li>
<li>JSON Hone Document 的存在</li>
</ul>

<h4>Web Finger</h4>

<ul>
<li>media-type

<ul>
<li>application/jrd+json</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>JRDと同等</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ユーザーアカウント</li>
</ul></li>
</ul>

<h3>Ontrogyカタログ</h3>

<h4>Schema.org RDF</h4>

<ul>
<li>サイト

<ul>
<li>schema.rdfs.org/</li>
</ul></li>
<li>語彙

<ul>
<li>schema.org core schemaにRDFaとして列挙</li>
</ul></li>
<li>セマンティクス

<ul>
<li>オンライン検索したい事象の種類</li>
</ul></li>
</ul>

<h4>FOAF</h4>

<ul>
<li>サイト

<ul>
<li>xmlns.com/foaf/spec/</li>
</ul></li>
<li>語彙

<ul>
<li>サイトよりindex.rdfをダウンロード</li>
</ul></li>
<li><p>セマンティクス</p>

<ul>
<li>人、組織に関すること</li>
</ul></li>
<li><p>非公式の産業標準</p></li>
<li><p>最も有名なRDF Schemaレポジトリ</p></li>
</ul>

<h4>vocab.org</h4>

<ul>
<li>サイト

<ul>
<li>vocab.org/</li>
</ul></li>
<li>語彙

<ul>
<li>いろいろ</li>
</ul></li>
<li>セマンティクス

<ul>
<li>ほんまいろいろ</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-13/">RESTful Web APIs 読書メモ(13)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(11)]]></title>
    <link href="http://ritalin.github.io/2015/03-22/restful-web-api-memo-11/"/>
    <updated>2015-03-22T09:57:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-22/restful-web-api-memo-11</id>
    <content type="html"><![CDATA[<h2>Chapter 10. The Hypermedia Zoo (Part. 2)</h2>

<ul>
<li>アプリケーションセマンティクスカタログ</li>
</ul>

<!-- more -->

<h3>IANA Registry (Link Relation)</h3>

<ul>
<li>media-type

<ul>
<li>分け隔てなくすべて</li>
</ul></li>
<li>セマンティクス

<ul>
<li>一般的なナビゲーション</li>
</ul></li>
<li>あらゆる表現に対して使用できる</li>
<li>各リンクリレーションには、human-readableなドキュメントと、定義元へのリンクが与えられている</li>
</ul>

<h3>Microformats Wiki</h3>

<ul>
<li>media-type

<ul>
<li>HTML</li>
</ul></li>
<li><p>セマンティクス</p>

<ul>
<li>オンラインで検索を行うことに関するもの</li>
</ul></li>
<li><p>hCalendar</p>

<ul>
<li>時間にまつわるイベントを記録</li>
<li>iCalendarベース (RFC2445)</li>
</ul></li>
<li><p>hCard</p>

<ul>
<li>人と組織について記述</li>
<li>vCardベース (RFC2426)</li>
<li>7章参照</li>
</ul></li>
<li><p>XFN</p>

<ul>
<li>人との関係を記述するリンクリレーションのセット</li>
</ul></li>
<li><p>XOXO</p>

<ul>
<li>ドキュメントの要点を記述</li>
<li>新たなアプリケーションセマンティクスは定義していない</li>
<li>htmlの範囲内でやりくりしている</li>
</ul></li>
<li><p>adr</p>

<ul>
<li>hCardのサブセット</li>
<li>住所のみを取り扱う</li>
</ul></li>
<li><p>geo</p>

<ul>
<li>hCardのサブセット</li>
<li>WGS84基準による緯度と経度</li>
</ul></li>
<li><p>hAtom</p>

<ul>
<li>ブログ投稿</li>
<li>Atomフィードベース(RFC4287)</li>
</ul></li>
<li><p>hListing</p>

<ul>
<li>雇用や広告に関するサービスを一覧</li>
<li>hCard, hCalendar, hReviewを組み合わせたもの</li>
</ul></li>
<li><p>hMedia</p>

<ul>
<li>がぞう、ビデオ、オーディオについての基本的なメタデータ</li>
</ul></li>
<li><p>hNews</p>

<ul>
<li>hAtomの拡張</li>
<li>ニュース記事を追加する</li>
</ul></li>
<li><p>hProduct</p>

<ul>
<li>製品リスト</li>
</ul></li>
<li><p>hRecipe</p>

<ul>
<li>レシピ</li>
</ul></li>
<li><p>hResume</p>

<ul>
<li>Resume/CVs ???</li>
</ul></li>
<li><p>hReview</p>

<ul>
<li>レーティング付きレビュー</li>
</ul></li>
<li><p>html5由来のリンクリレーション</p>

<ul>
<li>author, nogollow, tag, license</li>
</ul></li>
</ul>

<h3>Micro Formats Wiki (Link Relation)</h3>

<ul>
<li>IANA未登録のものも含む</li>
</ul>

<h3>Schema.org</h3>

<ul>
<li>microdataの総本山</li>
<li>microformats wikiと類似したアプリケーションセマンティクスが多く登録されている</li>
<li>主に利用者視点</li>
</ul>

<h3>Dublin Core</h3>

<ul>
<li>(うまく纏めれなかった・・・)</li>
</ul>

<h3>Activity Streams</h3>

<ul>
<li>Activityと呼ばれるオンライン活動(ビデオをみる、ブログを投稿する) を表現する標準

<ul>
<li>Activity

<ul>
<li>オンラインを通して対話することに関するアプリケーションセマンティクス

<ul>
<li>Article, Event, Group, Person,&#8230;</li>
</ul></li>
</ul></li>
<li>Atomフィードとして表現する</li>
<li>JSON版もある

<ul>
<li>ハイパーメディアコントロールではない</li>
</ul></li>
</ul></li>
<li>Actor, Verb, Objectで構成される

<ul>
<li>Actor

<ul>
<li>たいてい利用者</li>
</ul></li>
<li>Verb

<ul>
<li>Actorが何か行うこと</li>
<li>不安定な状態遷移名

<ul>
<li>join, follow, cancel</li>
</ul></li>
</ul></li>
<li>Object

<ul>
<li>ActorがなにかVerbする対象</li>
</ul></li>
</ul></li>
<li>schema.orgのmicrodataに多くの重複が見受けられる</li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-29/restful-web-api-memo-15/">RESTful Web APIs 読書メモ(15)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(10)]]></title>
    <link href="http://ritalin.github.io/2015/03-22/restful-web-api-memo-10/"/>
    <updated>2015-03-22T09:43:39+09:00</updated>
    <id>http://ritalin.github.io/2015/03-22/restful-web-api-memo-10</id>
    <content type="html"><![CDATA[<h2>Chapter 10. The HyperMedia Zoo (Part. 1)</h2>

<ul>
<li>ハイパーメディアフォーマットカタログ

<ul>
<li>ドメイン特化フォーマット </li>
<li>純粋ハイパーメディアフォーマット</li>
</ul></li>
</ul>

<!-- more -->

<h3>ドメイン特化フォーマット</h3>

<ul>
<li>特別なドメインの問題を表現するためにデザインされたフォーマット</li>
<li>特化されたアプリケーションセマンティクスが定義されている</li>
</ul>

<h4>Maze+XML</h4>

<ul>
<li>media-type: application/maze+xml</li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドを使ったリンクによるナビゲーション</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>迷路ゲーム</li>
</ul></li>
<li>5章参照</li>
<li>カスタムリレーションを定義することで拡張可能</li>
<li>XFornを使って、安全でないプロトコルを扱うこともできる</li>
</ul>

<h4>Open Search</h4>

<ul>
<li>mediatype

<ul>
<li>application/opensearchdescription+xml</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドによる検索</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>検索クエリ</li>
</ul></li>
<li>6章参照</li>
<li>検索フォームを表現する標準フォーマット</li>
<li><em>search</em> リンクリレーションを定義</li>
<li>検索結果の表現は定義されていない</li>
</ul>

<h4>Problem Detail Documents</h4>

<ul>
<li>media-type

<ul>
<li>application/api-problem+json</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドによるナビゲーション</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>エラー報告</li>
</ul></li>
<li>HTTPステータスコードに、JSONとして構造化したhuman-readableなテキストを加える

<ul>
<li>title (必須) </li>
<li>describedBy (必須) 

<ul>
<li>human-readableな説明へのリンク</li>
</ul></li>
<li>supportId (オプション) 

<ul>
<li>問題の詳細な例へのリンク</li>
</ul></li>
</ul></li>
<li>エンドユーザー向けの例外報告ではなく、管理者向けの内部URL</li>
</ul>

<h4>SVG</h4>

<ul>
<li>media-type

<ul>
<li>image/svg+xml</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>XLinkと同じ</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ベクター画像</li>
</ul></li>
<li>別の画像リソースをリンクとして含めることができる

<ul>
<li>aタグを使用</li>
<li>ハイパーメディアコントロールではない</li>
<li>XLinkの <em>role</em> プロパティとしての立ち位置</li>
</ul></li>
<li>XFormを埋め込むことで、プロトコルセマンティクスを追加できる</li>
<li>html5のsvgタグで、インラインに埋め込むことができる</li>
</ul>

<h4>VoiceXML</h4>

<ul>
<li>media-type

<ul>
<li>application/voicexml+xml</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドによるナビゲーション</li>
<li>GET(安全)やPOST(安全でない)メソッドによる任意の状態遷移</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>会話</li>
</ul></li>
<li>電話間における、会話の通信フォーマット</li>
</ul>

<h4>GeoJSON</h4>

<ul>
<li>media-type

<ul>
<li>application/json</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドによる座標系のトランスクルージョン</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>地理的な特徴、及びそのコレクション</li>
</ul></li>
<li>地理的な特徴を表現するフォーマット</li>
<li>ユーザビリティに悪影響をもたらす欠陥フォーマット</li>
<li>ハイパーメディアコントロールをもたない

<ul>
<li>URLに見えるただの文字列の塊</li>
</ul></li>
<li>素のJSONと区別する術はない

<ul>
<li>解決策は、profileを提供すること</li>
<li>そんなもん公式に提供されてないけどモナ！</li>
<li>
# コレクションパターンフォーマット</li>
</ul></li>
<li>itemリソース

<ul>
<li>GET, PUT, DELETメソッドに応答する</li>
<li>構造化された表現にフォーカス</li>
</ul></li>
<li>collectionリソース

<ul>
<li>GET, POST(append)メソッドに応答する</li>
<li>itemリソースへのリンクにフォーカス</li>
</ul></li>
</ul>

<h4>Collection+JSON</h4>

<ul>
<li>media-type

<ul>
<li>application/collection+json</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>コレクションパターン(GET/POST/PUT/DELETE)</li>
<li>GETメソッドによる検索</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>コレクションパターン(collection, item) </li>
</ul></li>
<li>6章参照</li>
<li>JSONによるAtomPub代替フォーマット</li>
</ul>

<h4>Atom Publishing Protocol</h4>

<ul>
<li>media-type
*application/atom+xml

<ul>
<li>application/atomsvc+xml</li>
<li>application/atomcat+xml</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>コレクションパターン(GET/POST/PUT/DELETE)</li>
<li>検索拡張(GET)</li>
<li>フォームナビゲーション拡張(GET)</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>コレクションパターン(feed/entry)

<ul>
<li>feed

<ul>
<li>Blog投稿のセマンティクス

<ul>
<li>autor, title, category,&#8230;</li>
</ul></li>
</ul></li>
<li>entry

<ul>
<li>バイナリエントリ

<ul>
<li>画像等</li>
</ul></li>
<li>メタデータをもつAtomエントリ</li>
</ul></li>
</ul></li>
</ul></li>
<li>RFC5023, RFC4287</li>
<li>6章参照</li>
<li>RESTful APIの先駆け</li>
<li>Google API(GData)の基盤として用いられている</li>
</ul>

<h4>OData</h4>

<ul>
<li>media-type

<ul>
<li>application/json; odata=fullmetadata</li>
<li>application/json; odata=minimalmetadata</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>修正コレクションパターン(GET/POST/PUT/DELETE/PATCH)</li>
<li>GETメソッドによるフィルタ、並び替え</li>
<li>GET(安全)、POST(安全でない)による任意の状態遷移</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>コレクションパターン(feed/entry)</li>
</ul></li>
<li>AtomPubベース</li>
<li>JSONオブジェクトのプロパティはsemantic descriptorとして機能する</li>
<li><em>odata.</em> で始まるプロパティは、ハイパーメディアコントロール、またはメタデータ

<ul>
<li>odata.id

<ul>
<li>エントリリソースの一意的なID

<ul>
<li>たいていURI</li>
</ul></li>
</ul></li>
<li>hoge@odata.type

<ul>
<li>プロパティの型を示すメタデータ</li>
</ul></li>
<li>odata.editLink

<ul>
<li>atomPubにおけるeditリレーションと同じ</li>
</ul></li>
<li>hoge@odata.navigationLinkUrl

<ul>
<li>ほかのリソースへのハイパーメディアリンク</li>
</ul></li>
</ul></li>
<li>コレクションの暗黙的なフィルタと並び替えをサポート

<ul>
<li>フォームから明示的に指示するものではない</li>
<li>Urlで宣言的なルールを指示する

<ul>
<li>posts$filter=substringof(&#39;hoge&#39;,Content)</li>
<li>複合条件の場合、<em>+and+</em> で連結する</li>
</ul></li>
</ul></li>
<li>状態遷移

<ul>
<li>function

<ul>
<li>GET(安全)な状態遷移

<ul>
<li>暗黙的なフィルタを使用できない複雑なクエリに対して使用される</li>
<li>クライアントは、odata.metadataに示されるスキーマ記述言語(SDL)へのリンクをたどり、構築するクエリを学ぶ必要がある</li>
</ul></li>
</ul></li>
<li>action

<ul>
<li>POST(安全でない)状態遷移</li>
</ul></li>
</ul></li>
<li>メタデータの外だし

<ul>
<li>odata.metadataでSDLへのリンクだけを書き記す

<ul>
<li>構造がシンプルになる</li>
<li>APIの修正と同時にSDLのメンテも必要

<ul>
<li>インピーダンスミスマッチを起こしやすい</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h1>純粋ハイパーメディアフォーマット</h1>

<ul>
<li>自身がアプリケーションセマンティクスを持たない汎用フォーマット</li>
<li>プロトコルセマンティクスのみ持つ</li>
</ul>

<h4>HTML</h4>

<ul>
<li>media-type

<ul>
<li>application/xhtml+xml</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドによるナビゲーション</li>
<li>GET(安全)、POST(安全でない)メソッドによる任意の状態遷移</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ドキュメントに埋め込まれたhuman-readable表現</li>
</ul></li>
<li>7章参照</li>
<li>microdataやmicroformatsを直接埋め込むことができる</li>
<li>scriptタグで実行コードを埋め込むことができる</li>
<li>webブラウザで表示できるので、デバッグが容易</li>
</ul>

<h4>HAL</h4>

<ul>
<li>media-type

<ul>
<li>application/hal+json</li>
<li>application/hal+xml</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>リンクによる任意の状態遷移</li>
<li>httpメソッドを明示的に指定できない</li>
<li>human-readableなドキュメントに明記するのみ</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>7章参照</li>
</ul>

<h4>Siren</h4>

<ul>
<li>media-type

<ul>
<li>application/vnd.siren+json</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドによるナビゲーション</li>
<li>GET(安全)、POST/PUT/DELETE(安全でない)メソッドによる <em>action</em> をとおした任意の状態遷移</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>あって無いようなもの</li>
</ul></li>
<li>htmlのdivタグをjsonで書き下したentityを記述する

<ul>
<li>entity要素

<ul>
<li>classやpropertyのリストを持てる</li>
<li>htmlのaタグをのようなlinksのリストを持てる</li>
<li>htmlのformタグのようなactionsのリストを持てる</li>
<li>子entryを持てる</li>
</ul></li>
</ul></li>
<li>状態遷移図はHALとHTMLの中間</li>
</ul>

<h4>Link Header</h4>

<ul>
<li>media-type

<ul>
<li>なし(httpヘッダとして使う) </li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドによるナビゲーション</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>RFC5988で定義</li>
<li>4章参照</li>
<li>画像やpure JSONにハイパーメディアコントロールを付与する</li>
<li>relパラメータに任意のリンクリレーションを与える</li>
<li>Link Headerを使うと、pure JSONにprofileを結びつけることができる</li>
</ul>

<h4>Lication, Content-Location Header</h4>

<ul>
<li>media-type

<ul>
<li>なし(httpヘッダとして使う) </li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>httpレスポンスコードに依存</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>1〜3章、付録B参照</li>
<li>RFC2616</li>
<li>Content-Location

<ul>
<li>現在のリソースの正規の位置を示す

<ul>
<li>IANAで定義されたcanonicalリレーションと同等</li>
</ul></li>
</ul></li>
<li>Location

<ul>
<li>201(Created)

<ul>
<li>作成されたリソースへのリンクを示す</li>
</ul></li>
<li>301(Moved Prrmanently)

<ul>
<li>リダイレクト先を示す</li>
</ul></li>
</ul></li>
</ul>

<h4>URL List</h4>

<ul>
<li>media-type

<ul>
<li>text/url-list</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>RFC2483で定義</li>
<li>urlの一覧を取得</li>
<li>リンクリレーションをもたないため、ハイパーメディアコントロールになり得ない</li>
</ul>

<h4>JSON Home Document</h4>

<ul>
<li>media-type

<ul>
<li>application/json-home</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>あって無いようなもの</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>より洗練されたurl list</li>
<li>JSONオブジェクトのキーとしてリンクリレーション、値にUrlを指定

<ul>
<li>ハイパーメディアコントロールたり得る</li>
</ul></li>
<li>URL Templateが使用可能

<ul>
<li>テンプレートスロットはhref-varsで指定されるprofileを参照する</li>
</ul></li>
<li><em>hints</em> を与えることで、メソッドを明示できる

<ul>
<li>&quot;hints&quot;: { &quot;allow&quot;: [ &quot;POST&quot; ] }</li>
<li>リンクのアプリケーションセマンティクスは指定できない</li>
</ul></li>
<li>profileと組み合わせることで、human-readableなAPIをmachine-readableなものに変貌させることができる</li>
</ul>

<h4>Link-Template Header</h4>

<ul>
<li>media-type

<ul>
<li>なし(httpヘッダとして使う) </li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドによるナビゲーション</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>RFC6570で定義(時間切れで棄却) </li>
<li>機能的にはLink Headerと同様</li>
<li>リンク先としてURL Templateが使用可能</li>
<li>var-baseパラメータを使って、スロット変数のためのprofileを指定する</li>
</ul>

<h4>WADL</h4>

<ul>
<li>media-type

<ul>
<li>application/vnd.sun.wadl+xml</li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>完全な汎用フォーマット</li>
<li>あらゆるweb APIのプロトコルを模倣できる</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>拡張のための最小限だけ</li>
</ul></li>
<li>requestタグで任意のhttpメソッドを指定する</li>
<li>entity-bodyを含む、あらゆるhttpヘッダを指定できる</li>
<li>メタデータはXML Schemaを用いる</li>
<li>docタグにprofileを埋め込むことができる</li>
<li>いくつかのHAX-RSの実装がAPIとして、WADLを吐き出す

<ul>
<li>SOAP同様、インピーダンスミスマッチを生む要因となる</li>
</ul></li>
</ul>

<h4>XLink</h4>

<ul>
<li>media-type

<ul>
<li>なし(任意のxmlに埋め込む形で使用) </li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GETメソッドによるナビゲーション</li>
<li>GETメソッドによるトランスクルージョン

<ul>
<li>リソースの埋め込みのようなもの</li>
</ul></li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>素のxmlにハイパーメディアリンクを埋め込む拡張</li>
<li>XLink自身、タグは定義されていない</li>
<li>xmlに付与する属性のみ定義

<ul>
<li>xlink:arcrole

<ul>
<li>URIを使ってリンクリレーションを表現する</li>
</ul></li>
<li>xlink:show

<ul>
<li>ナビゲーション方法を変更する

<ul>
<li>replace

<ul>
<li>htmlのaタグのように内容を置換する</li>
</ul></li>
<li>embed

<ul>
<li>htmlのimgタグのように内容を埋め込む</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h4>XForms</h4>

<ul>
<li>media-type

<ul>
<li>なし(任意のxmlに埋め込む形で使用) </li>
</ul></li>
<li>プロトコルセマンティクス

<ul>
<li>GET(安全)、POST/PUT/DELETE(安全でない)メソッドによる、任意の状態遷移</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>ない！</li>
</ul></li>
<li>素のxmlにハイパーメディアフォームを埋め込む拡張</li>
<li>XLinkとは異なり、自信のタグを定義している

<ul>
<li>xforms:model

<ul>
<li>htmlにおけるformタグと同機能</li>
</ul></li>
<li>xforms:submission

<ul>
<li>xforms:modelの子要素</li>
<li>htmlにおけるformタグのaction属性とmethod属性を担う</li>
</ul></li>
<li>xforms:instance

<ul>
<li>xforms:submissionの子要素</li>
<li>GETメソッドのクエリ文字列やPOSTメソッドのentity-bodyの構築方法を例示する</li>
</ul></li>
<li>xforms:input

<ul>
<li>htmlにおけるinputタグと同機能</li>
</ul></li>
<li>xforms:submit

<ul>
<li>htmlにおけるinput type=&quot;submit&quot;と同機能</li>
</ul></li>
</ul></li>
</ul>

<hr>

<h2>後編へつづく</h2>

<p><a href="http://ritalin.github.io/2015/03-22/restful-web-api-memo-11/">RESTful Web APIs 読書メモ(11)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(9)]]></title>
    <link href="http://ritalin.github.io/2015/03-19/restful-web-api-memo-09/"/>
    <updated>2015-03-19T23:00:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-19/restful-web-api-memo-09</id>
    <content type="html"><![CDATA[<h2>Chapter 9. The Design Procedure</h2>

<ul>
<li>API設計とは、プロトコルセマンティクスとアプリケーションセマンティクスを設計すること</li>
</ul>

<!-- more -->

<h3>最も単純な手順</h3>

<ol>
<li>表現として使用するmedia-typeを選択する

<ul>
<li>プロトコルセマンティクスとアプリケーションセマンティクスを選択することでもある</li>
<li>application/json

<ul>
<li>今日、幅広く使われている形式</li>
<li>fiat standardとなるので再利用出来ない</li>
</ul></li>
</ul></li>
<li>Profileを用意する</li>
</ol>

<h3>詳細な手順</h3>

<ol>
<li>クライアントがAPIを通して、get/putする情報の素片をリストアップする

<ul>
<li>情報の素片は階層構造をもったsemantic descriptor (リソースの表現) となる

<ul>
<li>この時点では、用語のブレは気にしない(first-name, first_name)</li>
</ul></li>
<li>語彙は、データベーススキーマやオブジェクトモデルからはもってこないこと

<ul>
<li>クライアントコードがサーバーサイドに依存してしまうため</li>
</ul></li>
<li>media-type在りきでデータ構造を決定しないこと

<ul>
<li>6. まで我慢する</li>
</ul></li>
<li>IANA登録済みのlink relationと重複させないこと

<ul>
<li>ページネーション

<ul>
<li>first, next, current</li>
<li>next-archive, prev-archive (RFC5005)</li>
</ul></li>
<li>メッセージスレッド

<ul>
<li>replies (RFC4685)</li>
</ul></li>
<li>リソース状態の履歴管理(RFC5829)

<ul>
<li>latest-version</li>
<li>successor-version</li>
<li>predecessor-version</li>
<li>working-copy</li>
<li>working-copy-of</li>
</ul></li>
<li>リソース状態の編集

<ul>
<li>edit</li>
<li>edit-media</li>
</ul></li>
</ul></li>
</ul></li>
<li>APIの状態遷移図を描く

<ul>
<li>一つの状態に一つの表現を割り当てる</li>
<li>一つの状態遷移が一つの矢印となる</li>
<li>httpメソッドはまだ割り当てない</li>
<li>冪等性と安全性は考えておくべき</li>
<li>link relationが発見されるかもしれない

<ul>
<li>構造化された内と外との間のリンク</li>
<li>用語がアプリケーション状態の変化をもたらすのであれば、その用語はリレーション</li>
<li>拡張リンクリレーション

<ul>
<li>http://example.com/maze#exit</li>
<li>profile取り込むことなく使用可能</li>
</ul></li>
</ul></li>
<li>階層構造が変化するかもしれない</li>
<li>状態間は、グループ化されたdescriptor (ValueObject)が行き来する</li>
<li>状態遷移におけるトップレベル表現を設ける

<ul>
<li>ほかの状態へは、ハイパーメディアコントロールを通して</li>
</ul></li>
</ul></li>
<li>semantic descriptorとlink relationが満足するまで、1, 2を繰り返す

<ol>
<li>用語のブレは解消しておくこと</li>
</ol></li>
<li>用語が既知のprofileに存在するのなら、それに置き換える

<ul>
<li>IANAに登録されたリレーション</li>
<li>schema.orgに登録された用語</li>
<li>alps.ioに登録された用語</li>
<li>ドメイン特化フォーマットで使用される用語、などなど</li>
<li>既知の語彙は間違った理解を減らせる</li>
<li>profileの再利用は、書くべきドキュメント量を減らせる</li>
<li>profileの再利用は、ライブラリの再利用を促せる</li>
<li>たいていはprofileを使用せず、media-typeに結びつけてしまっている

<ul>
<li>一つのAPIに対して複数のmedia-typeを独自定義せず、複数のprofileを利用する</li>
</ul></li>
<li>金融、法務関係のprofileは、未整備のため再利用は難しい</li>
</ul></li>
<li>用語と状態遷移図が満足するまで、1 - 3を繰り返す</li>
<li>プロトコルセマンティクスとアプリケーションセマンティクスに適合するmedia-typeを選択する

<ul>
<li>運が良ければ、ドメイン特化フォーマットが見つかるかもしれない</li>
<li>独自定義する場合、標準的な命名規則に従う

<ul>
<li>application/vnd.(org name).(base type)</li>
<li>(例) application/vnd.hoge.maze+xml</li>
</ul></li>
<li>より汎用的な利用を考えているのならIANAにmedia-typeを登録する

<ul>
<li>RFC6838の4, 5節の手順に従う</li>
<li>JSONベースならRFC4627を目を通すべし</li>
<li>XMLベースならRFC3023に目を通すべし</li>
</ul></li>
<li>可能な限り、ハイパーメディアフォーマットを選択する</li>
<li>コレクションパターン

<ul>
<li>Collection+JSON</li>
<li>AtomPub</li>
<li>OData</li>
</ul></li>
<li>有向グラフ構造

<ul>
<li>HTML</li>
<li>HAL</li>
<li>Siren</li>
</ul></li>
<li>読み取り専用API

<ul>
<li>HTML</li>
<li>HAL</li>
<li>JSON-LD</li>
</ul></li>
<li>安全でないメソッドを使用する場合

<ul>
<li>Hydra</li>
<li>Collection+JSON</li>
</ul></li>
</ul></li>
<li>未知の用語に対して、profileを用意する

<ul>
<li>machine-readable フォーマット

<ul>
<li>Alps<br></li>
<li>JSON-LD</li>
<li>XMDPベースのwebページ</li>
</ul></li>
<li>profileでlink relationを定義した場合、IANAのものよりも優先される

<ul>
<li>意図的にやるべきではない</li>
</ul></li>
</ul></li>
<li>状態遷移図を満たすサーバー実装を書く</li>
<li>トップのURLを公開する

<ul>
<li>状態遷移図のゲートウェイをトップURLとする</li>
<li>Profileを配置する

<ul>
<li>自サイト</li>
<li>alps.io</li>
</ul></li>
<li>APIの要約</li>
<li>利用例</li>
<li>サンプルコード</li>
<li>認証手順</li>
<li>Well known URIs Registry (RFC5785)

<ul>
<li>CoRE Link Formatの場合

<ul>
<li>/.well-knoen/coreに問い合わせ</li>
<li>相対URLは、IANAレジストリに登録</li>
<li>ほかリソースのハイパーメディアリンクの一覧を取得できる</li>
</ul></li>
<li>ホストメタデータの取得

<ul>
<li>/.well-known/host-meta.json </li>
<li>または、/.well-known/host-meta</li>
</ul></li>
<li>well known URIは、media-typeに関連付けられる</li>
</ul></li>
</ul></li>
</ol>

<h3>バージョニング</h3>

<ul>
<li>前提

<ul>
<li>第一にAPIのセマンティクスをhuman-readableドキュメントやハイパーメディアドキュメントの外に置くこと
*　変更に強くなる</li>
<li>既存のリソース定義を変更するのではなく、新しいリソースや状態遷移を追加するに留める</li>
</ul></li>
<li>URLに付与

<ul>
<li><li class="v1" href="v1" />のような感じ</li>
<li>media-typeに付与

<ul>
<li>コンテントネゴシエーションとして指定

<ul>
<li>Accept: application/vnd.hoge?version=2

<ul>
<li>media-typeはAPIではないのでやめといた方がいい</li>
</ul></li>
</ul></li>
</ul></li>
<li>profileを使う

<ul>
<li>破壊的変更はhuman-readableに記述</li>
<li>非破壊変更はmachine-readableなハイパーメディアで記述</li>
</ul></li>
<li>リソーススキーマの変更

<ul>
<li>後方互換性を保ちたいなら、異なるURIを持つ新たなリソースを定義する</li>
</ul></li>
</ul></li>
</ul>

<h3>古いAPIの止め方</h3>

<ol>
<li>deplecatedをマークし、公式チャンネルでアナウンスする</li>
<li>しばらくしたら、deplecatedマークしたバージョンはバグ修正しないことをアナウンスする</li>
<li>更に幾つか待って、停止の期限をアナウンスする</li>
<li>停止日が訪れたら、古いAPIのリクエストに対し、410(Gone)を返し、新しいAPIへのリンク先を案内する</li>
</ol>

<h3>既存のAPIをRESTfulにする場合</h3>

<ul>
<li><p>WSDL</p>

<ul>
<li>非RESTful API</li>
<li>サーバー実装と自動生成されるクライアント実装が密結合となる</li>
<li>サーバー実装の変更をクライアントサイドに反映出来ない</li>
</ul></li>
<li><p>既存のJSONベースAPIにハイパーメディアを追加する場合</p>

<ul>
<li>名前(application descriptor) を変更しない</li>
<li>media-typeを変更しない</li>
<li>安全でないリレーションを追加する場合、profileとしてHydraをもつJSON-LDがオススメ</li>
</ul></li>
<li><p>既存のXMLベースのAPIにハイパーメディアを追加する場合</p>

<ul>
<li>XFirn, XLinkをハイパーメディアコントロールとして使用する</li>
</ul></li>
<li><p>たとえわけの分からないレスポンスだったとしても</p>

<ul>
<li>media-typeやrelationがIANAに登録されている</li>
<li>profileドキュメントへのリンクがあれば、なんとか解析はできる

<ul>
<li>profileはmachine-readableに加えて、human-readableな情報があると尚よし</li>
</ul></li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-22/restful-web-api-memo-10/">RESTful Web APIs 読書メモ(10)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(8)]]></title>
    <link href="http://ritalin.github.io/2015/03-11/restful-web-api-memo-08/"/>
    <updated>2015-03-11T23:26:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-11/restful-web-api-memo-08</id>
    <content type="html"><![CDATA[<h2>Chapter 8. Profiles</h2>

<ul>
<li>アプリケーション特化の拡張機能に対するドキュメント化</li>
<li><p>アプリケーション特化の用語の定義、ドキュメント化</p></li>
<li><p>現在、一般的用いられていることは、大量のhuman-readableなドキュメントを作成すること</p>

<ul>
<li>APIドキュメントについてはRESTful(自己記述性メッセージ)でない</li>
</ul></li>
</ul>

<!-- more -->

<h3>クライアントアプリはいかにしてドキュメントをさがすのか？</h3>

<ul>
<li><p>クライアントがリクエストやレスポンスの意味を推測すべきではない</p>

<ul>
<li>メッセージ自身が、詳細に説明すべき</li>
</ul></li>
<li><p>レスポンスはクライアントがなすべきことを全て含めるべき</p>

<ul>
<li>Content-type

<ul>
<li>リソースの解析方法を示す</li>
</ul></li>
<li>ハイパーメディアコントロール

<ul>
<li>次に発行すべきリクエストをレスポンスに含める</li>
<li>プロトコルセマンティクスを明示する</li>
</ul></li>
<li>ドメイン特化フォーマットの場合

<ul>
<li>リソースに問題領域の状態遷移を含める</li>
<li>アプリケーションセマンティクスを付与する</li>
</ul></li>
</ul></li>
<li><p>多くの場合、プロトコルセマンティクスとアプケーションセマンティクスの両方をフォーマットから読み取ることはできない</p>

<ul>
<li>仕様Profileが欠損している</li>
</ul></li>
</ul>

<h3>Profile</h3>

<ul>
<li><p>media-typeを元にリソースを解析しても得られない仕様(APIドキュメント)</p>

<ul>
<li>たいていHuman-readableな文書</li>
<li>machine-readable profile

<ul>
<li>linkやdescripterで記述されたhuman-readableなドキュメント(Profile)を自動収集できる</li>
</ul></li>
</ul></li>
<li><p>定義(RFC6906)</p>

<ul>
<li>リレーションを使用してProfileとリンク(rel=&quot;profile&quot;)

<ul>
<li>IANAにそのリレーションが登録されている

<ul>
<li>relをサポートするあらゆるハイパーメディアコントロールで利用可能

<ul>
<li>htmlのaタグ</li>
<li>html, Collection+JSON, HALのlinkタグ</li>
<li>RFC5988のLINKヘッダ</li>
</ul></li>
</ul></li>
<li>Ontent-Typeパラメータに追記

<ul>
<li>application/collection+json;profile=&quot;(リンク先URL)&quot;</li>
<li>すべてのmedia-typeで使用できるわけではない(RFC4288)

<ul>
<li>Collection+JSON</li>
<li>JSON-LD</li>
<li>HAL</li>
<li>XHTML</li>
</ul></li>
<li>httpヘッダでprofileリンクを示したいなら、すべてで使えるLINKヘッダを使うべき</li>
</ul></li>
<li>Microdataのitemtype

<ul>
<li>Urlで、リンク先のprofileを指定する</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h3>プロトコルセマンティクスProfile</h3>

<ul>
<li>どのようなHTTPリクエスト発行されるのかについて</li>
<li>フリーフォームな文体で記述</li>
<li>ハイパーメディアコントロールを持たないmedia-type(JSON)に対して用意</li>
<li>HALのようにプロトコルセマンティクスが削ぎ落とされている場合に用意</li>
<li>ハイパーメディアコントロールであれば、リンクリレーションを用いて指定

<ul>
<li>ハイパーメディアコントロールから駆動される状態遷移を記述した文字列

<ul>
<li>GETでアプリケーション状態を遷移</li>
<li>POST, PUT,DELETEでリソース状態を遷移</li>
</ul></li>
</ul></li>
</ul>

<h3>アプリケーションセマンティクスProfile</h3>

<ul>
<li><p>人が用語を理解するようにコンピュータにも理解させること</p></li>
<li><p>利用するデータ構造、パラメータなどの説明文を用意</p></li>
<li><p>用語をセマンティクス記述子に表記</p>

<ul>
<li>microformats

<ul>
<li>class属性</li>
</ul></li>
<li>Siren

<ul>
<li>classエンティティ</li>
</ul></li>
<li>生JSON

<ul>
<li>オブジェクトキー</li>
</ul></li>
<li>生XML

<ul>
<li>タグ名</li>
</ul></li>
</ul></li>
</ul>

<h3>XMDP</h3>

<ul>
<li>machine-readable profileの一種</li>
<li>ほかのmicroformatを説明するためのmicroformat</li>
<li>class属性に特別な意味があることを伝えられる

<ul>
<li>自動的に理解するわけではなく、そんなツールを書く必要がある</li>
</ul></li>
</ul>

<h3>ALPS</h3>

<ul>
<li>XMDP同様、meta-microformst</li>
<li>HTML専用</li>
<li>プロパティ

<ul>
<li>descriptor

<ul>
<li>一つの用語に対して一つ作る</li>
<li>type=&quot;semantic&quot;</li>
<li>子要素のdocタグにhuman-readableな説明を書く</li>
<li>docタグ以外はmachine-readable</li>
<li><descripter href="#fn" />のようにすることで、ハイパーメディアコントロールにすることもできる</li>
</ul></li>
</ul></li>
</ul>

<h3>JSON-LD</h3>

<ul>
<li>元のJSONドキュメントに&quot;context&quot;と呼ばれるmachin-readableドキュメントを組み込む</li>
<li>APIの変更なしに組み込むことが可能</li>
<li>RDFからの派生</li>
<li>アプリケーションセマンティクスを直接説明せず、ハイパーメディアリンクを添えるだけ

<ul>
<li>&quot;n&quot;: <url></li>
<li>&quot;photo_link&quot;: { &quot;@id&quot;: <url>, &quot;@type&quot;: &quot;@id&quot; }</li>
</ul></li>
</ul>

<h3>API自身にドキュメントを埋め込む</h3>

<ul>
<li><p>APIにhuman-readableドキュメントを埋め込めるフォーマットを用いる</p>

<ul>
<li>HTML

<ul>
<li>inputタグのvalue属性</li>
</ul></li>
<li>HAL

<ul>
<li>linkタグのtitle属性</li>
</ul></li>
<li>Siren

<ul>
<li>actionオブジェクトのtitleフィールド</li>
</ul></li>
</ul></li>
<li><p>machine-readableとhuman-readableドキュメントの両方を用意することについて</p>

<ul>
<li>人との対話により動くクライアント、自動化クライアントの両対応のため</li>
<li>両方のセマンティクスギャップをより縮める</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-19/restful-web-api-memo-09/">RESTful Web APIs 読書メモ(9)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(7)]]></title>
    <link href="http://ritalin.github.io/2015/03-09/restful-web-api-memo-07/"/>
    <updated>2015-03-09T21:08:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-09/restful-web-api-memo-07</id>
    <content type="html"><![CDATA[<h2>Chapter 7. Pure hypermedia Design</h2>

<ul>
<li>コレクションパターンは強力であるが、何でもかんでも使えるではない</li>
<li><p>MAZE+xmlのコレクションパターンでの表現（5章）</p>

<ul>
<li>どう見ても迷路ゲームのアプリケーションセマンティクスにマッチしていない</li>
</ul></li>
<li><p>APIの設計方針として、汎用的なハイパーメディアを用いることができる</p></li>
</ul>

<!-- more -->

<h3>HTML</h3>

<ul>
<li>多くのOS標準搭載されたブラウザにレンダリングさせてデバッグできる</li>
<li>XMLやJSONよりも、よりドキュメントとしての構造を強いている</li>
<li>標準化されたハイパーメディアコントロールを有している

<ul>
<li>formタグ(method=&quot;GET&quot; = outbound link

<ul>
<li>inputタグによるURIテンプレート代替</li>
</ul></li>
<li>formタグ(method=&quot;POST&quot; = リソース生成依頼</li>
<li>linkタグ(rel=&quot;stylesheet&quot;) = embedded link</li>
<li>linkタグ(rel=&quot;self&quot;) = outbound link</li>
<li>aタグ = outbound link</li>
<li>imgタグ、scriptタグ = embedded link</li>
<li>特別な問題領域に特化したものではない</li>
</ul></li>
<li><p>解析 / 生成のためのツールが多くある</p></li>
<li><p>データ構造としてのHTML</p>

<ul>
<li>ol = JSON順序リスト</li>
<li>ul = JSON非順序リスト</li>
<li>dl = JSONオブジェクト</li>
<li>table = 二次元配列</li>
<li>div/span = グループ化</li>
</ul></li>
<li><p>汎用属性</p>

<ul>
<li>rel

<ul>
<li>IANAに登録されたリレーションを用いることで、HTMLにアプリケーションセマンティクスを組み込める</li>
</ul></li>
<li>id

<ul>
<li>文書内で一意の識別子</li>
<li>idでアプリケーションセマンティクスをフックするのはオススメではない

<ul>
<li>複数の文書をマージしたい場合に一意性が保証出来ないため</li>
</ul></li>
</ul></li>
<li>class

<ul>
<li>最も柔軟性のある属性</li>
<li>wwwではcssによるフォーマッティングに用いられる</li>
<li>アプリケーションセマンティクスとしては、グループ化のタグとして用いることができる</li>
</ul></li>
</ul></li>
</ul>

<h3>microformat</h3>

<ul>
<li>htmlにアプリケーションセマンティクスを付与する技術</li>
<li>classとrel属性に与える値のみを定義する</li>
<li>html + microformatでドメイン特化なフォーマットを再現できる</li>
<li>hCard

<ul>
<li>グループ化やフィールドのためのclassのみが定義されている</li>
<li>hCard自身はハイパーメディアコントロールではないが、htmlから拝借して、connectednessを実現できる</li>
<li>どのhtmlタグに付けるかは自由</li>
<li>vCard(RFC6350)を元にしている

<ul>
<li>ハイパーメディアコントロールではない</li>
</ul></li>
</ul></li>
</ul>

<h3>Microdata</h3>

<ul>
<li>html5用、microformat改良版</li>
<li>総本山はschema.org</li>
<li>microformstにおけるclassの置き換え</li>
<li>リレーションは定義出来ない</li>
<li>class属性は本来、アプリケーションセマンティクスを体現する場ではない</li>
<li>プロパティ

<ul>
<li>itemprop

<ul>
<li>グループ名、フィールド名の定義</li>
</ul></li>
<li>itemscope

<ul>
<li>Microdataによる表現を開始するタグに付与</li>
</ul></li>
<li>itemtype

<ul>
<li>付与したタグをハイパーメディアコントロールにする</li>
<li>値はURL</li>
</ul></li>
<li>itemid</li>
<li>itemref</li>
</ul></li>
</ul>

<h3>フォームにアプリケーションセマンティクスを加えること</h3>

<ul>
<li><p>リンクリレーションは、リソース間の関連を記述するもの</p>

<ul>
<li>自身と同じURLに異なるリンクリレーションのリンクを貼る =&gt; リソース状態が変更されることを意味する</li>
<li>リンクはGETリクエストの発行となるため、HTTPメソッドの制約に反する</li>
</ul></li>
<li><p>HTMLフォームなら、POSTリクエストを発行できる</p>

<ul>
<li>リソース状態を変更することは制約に反しない</li>
<li>inputタグのclass属性にアプリケーションセマンティクスとなる用語を与える</li>
<li>アクションURLを組み立てるためのテンプレートは不要

<ul>
<li>formタグがアクションURLを持つため</li>
</ul></li>
<li>sublitタイプのinputタグを置いて初めて、状態遷移が可能となる

<ul>
<li>遷移させたくなければ、sublitを置く必要はない</li>
</ul></li>
</ul></li>
<li><p>リソース指向アプローチ</p>

<ul>
<li>リソースを識別し、そこにハイパーメディアを試みる作り</li>
<li>まずリソースを識別することに重きを置いている</li>
</ul></li>
<li><p>ハイパーメディア設計</p>

<ul>
<li>リソースを識別することよりも状態遷移を識別することの方が重要</li>
</ul></li>
</ul>

<h3>HTMLの限界</h3>

<ul>
<li>本来のHTMLは、ハイパーメディアフォーマットなどではなく、human-readableに特化した標準</li>
<li>全てのhttpプロトコルを実現できない

<ul>
<li>PUT, DELETEはJavascriptの手助けが必要</li>
</ul></li>
<li>formで構成できるリクエストは、application/x-www-form-urlencodedか、multipart/form-dataのいずれか</li>
<li>文字列と数字を区別しない

<ul>
<li>そのアプリケーションセマンティクスはhtmlの外で定義するしかない</li>
</ul></li>
<li>日付表現を定義していない

<ul>
<li>vCardのbdayはISO8601として個別に定義</li>
</ul></li>
</ul>

<h3>html5</h3>

<ul>
<li>timeタグ

<ul>
<li>特定のフォーマットでdate型やtimestamp型を表現</li>
</ul></li>
<li>meterタグ

<ul>
<li>特定の範囲内の測定値を表現</li>
</ul></li>
<li>audioタグ</li>
<li>videoタグ</li>
<li>sourceタグ</li>
<li>embedタグ</li>
<li>inputタグのvalidation

<ul>
<li>値としてdate, number, urlを表現</li>
<li>required属性で必須入力</li>
<li>クライアントサイドバリデーション</li>
</ul></li>
<li>formタグ

<ul>
<li>texp/plainメディアタイプのサポート</li>
</ul></li>
<li>Microdata

<ul>
<li>classs属性への意味づけ</li>
</ul></li>
<li>PUT, DELETEは引き続き未サポート</li>
</ul>

<h3>Hypermedia Application Language (HAL)</h3>

<ul>
<li>media-type

<ul>
<li>application/hal+xml</li>
<li>application/hal+json</li>
</ul></li>
<li>要素としてresourceとlinkタグのみを定義されている</li>
<li>resourceタグ

<ul>
<li>httpリソースの表現</li>
</ul></li>
<li>link

<ul>
<li>これ一つであらゆるハイパーメディアを扱える

<ul>
<li>GET, POST, PUT, DELETE, UNLINK</li>
<li>プロトコルセマンティクスを指定するすべはない</li>
<li>リレーションの意味を明示的にドキュメントとして残すしかない</li>
</ul></li>
</ul></li>
</ul>

<h3>Siren</h3>

<ul>
<li>JSONベースのハイパーメディアフォーマット</li>
<li>HTMLとCollection+JSONの合いの子のような立ち位置</li>
<li>entities

<ul>
<li>データをグループ化</li>
<li>htmlのdivタグ相当</li>
<li>URLを付与することでサブリソースとして振舞わせられる</li>
<li>links

<ul>
<li>別のリソースへのリンク先を記述</li>
</ul></li>
</ul></li>
</ul>

<h3>Semantics Challenge</h3>

<ul>
<li>httpプロトコルセマンティクス

<ul>
<li>リソースにGET, POSTなどのリクエストメソッドを割り当てる</li>
</ul></li>
<li>ハイパーメディア

<ul>
<li>サーバーで次に行わせたいリクエストを伝える仕組み</li>
</ul></li>
<li>アプリケーションセマンティクス

<ul>
<li>アプリケーション状態やリソース状態をハイパーメディアで制御すること</li>
</ul></li>
<li>ドメイン特化フォーマット

<ul>
<li>例: Maze+XML</li>
<li>プロトコルセマンティクスを定義</li>
<li>アプリケーションセマンティクスも定義</li>
<li>稀な存在</li>
</ul></li>
<li>標準フォーマット

<ul>
<li>Collection+JSON, AtomPubなど</li>
<li>プロトコルセマンティクス詳細に定義している

<ul>
<li>item-typeリソース = PUTに応答</li>
</ul></li>
<li>アプリケーションセマンティクスは未定義</li>
</ul></li>
<li>microformat

<ul>
<li>アプリケーションセマンティクスを定義</li>
<li>プロトコルセマンティクスは未定義</li>
</ul></li>
<li>HTML, HAL, Siren

<ul>
<li>プロトコルセマンティクスを定義</li>
<li>アプリケーションセマンティクスも定義</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-11/restful-web-api-memo-08/">RESTful Web APIs 読書メモ(8)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(6)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-06/"/>
    <updated>2015-03-08T22:47:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-06</id>
    <content type="html"><![CDATA[<h2>Chapter 6. The Collection Pattern</h2>

<ul>
<li>コレクションもまたリソース

<ul>
<li>  コレクションに含まれるリソースは&quot;item&quot;や&quot;entry&quot;、&quot;member&quot;と呼ばれる</li>
</ul></li>
<li>  Pagenation

<ul>
<li>  大量のコレクションメンバーを持つ場合、全てを一度に返すことは通常しない</li>
<li>  最初の一部だけをコレクションとして返し、残りはrel=&quot;next&quot;を付与したリンクだけを提供する

<ul>
<li>  nextはIANAで登録されている</li>
<li>  ほかにprev, first, lastもIANAで定義されている</li>
</ul></li>
<li>  Collection+JSONはリレーションを明示的にサポートしてはいない

<ul>
<li>  必要ならリレーションを組み込めばいい</li>
</ul></li>
</ul></li>
</ul>

<!-- more -->

<h3>Collection+JSON</h3>

<ul>
<li>問題領域とは独立した汎用フォーマット</li>
<li>手軽にREST制約を組み込める</li>
<li>httpを介して取得するリソースのためのプロトコルセマンティクス</li>
<li>プロパティ

<ul>
<li>href

<ul>
<li>コレクション自身へのリンク</li>
</ul></li>
<li>items

<ul>
<li>コレクションの要素</li>
<li>アプリケーション特化データの集合

<ul>
<li>href

<ul>
<li>要素へのリンク</li>
<li>GETリクエストで単独のリソースとして取得できる</li>
<li>PUTやDELETEで変更、削除</li>
</ul></li>
<li>links

<ul>
<li>要素に関連するほかのリソースへのリンク</li>
<li>例えば、本リソースに対する著者、出版社等</li>
<li>render=&quot;link&quot;

<ul>
<li></li>
</ul></li>
<li>render=&quot;image&quot;

<ul>
<li></li>
</ul></li>
</ul></li>
<li>data

<ul>
<li>要素を構成する内容</li>
<li>アプリケーションセマンティクスの要</li>
<li>&quot;name&quot;と&quot;value&quot;から成るJSONオブジェクトの集合</li>
<li>各ペアには備考として&quot;prompt&quot;をもたせられる</li>
</ul></li>
</ul></li>
</ul></li>
<li>links

<ul>
<li>コレクションに関連するほかの要素</li>
</ul></li>
<li>queries

<ul>
<li>コレクションを検索するためのテンプレート</li>
</ul></li>
<li>templates

<ul>
<li>コレクションに新しい要素を加えるためのテンプレート</li>
</ul></li>
<li>error

<ul>
<li>エラーメッセージ</li>
</ul></li>
</ul></li>
</ul>

<h3>AtomPub</h3>

<ul>
<li>Atomフォーマット

<ul>
<li>RSSに代わり、ニュースを同報する仕組みとしてRFC4287で標準化</li>
<li>ニュース記事を一つ以上のカテゴリに分類できる</li>
</ul></li>
<li>AtomPubはニュースを編集 / 発行(CRUD)などを行うためのAtomフォーマットを使ったワークフロー(RFC5023)</li>
<li>media-typeはapplication/atom+xml</li>
<li>新しいエントリーはURIにPOSTすることで行う</li>
<li>リンクにrel=&quot;edit&quot;を付与することで編集可能なエントリーであることを示す(PUTサポート) </li>
<li>Collection+JSONと同じコンセプトをもつ

<ul>
<li>コレクション要素は&quot;item&quot; -&gt; &quot;feed&quot;</li>
<li>Collection+JSONは汎用フォーマットなので、itemに特別なアプリケーションセマンティクスわ定義していない</li>
<li>AtomPubはニュース配信プロトコルなので、エントリーはニュース記事</li>
</ul></li>
<li>コレクションパターンのプラグイン基盤としても用いられる

<ul>
<li>Atom Threading Extension

<ul>
<li>RFC4685</li>
<li>メールスレッド表現</li>
<li>rel=&quot;replies&quot;</li>
</ul></li>
<li>Atom deleted entry element

<ul>
<li>RFC6721</li>
<li>エントリーを削除するのではなく墓石を置削除扱いとする</li>
</ul></li>
<li>Feed Paging and Archiving

<ul>
<li>RFC5005</li>
<li>アーカイブフィードコンセプトを定義</li>
<li>複数のリソースをまたがるきょだなフィードをPagingする方法</li>
<li>rel属性として、next-archive, prev-archive, currentを使う</li>
</ul></li>
<li>OpenSearch

<ul>
<li>xmlベースの検索プロトコル標準</li>
<li>rel=&quot;search&quot;</li>
<li>Collection+JSONにおけるqueriesプロパティど同等のもの</li>
</ul></li>
<li>PubSubHubbub

<ul>
<li>Atomフィードが更新されたときに通知を行うためのプロトコル</li>
<li>rel=&quot;hub&quot;</li>
</ul></li>
<li>これらのリレーションは全てIANAに登録されている

<ul>
<li>何の説明もなく使用できる</li>
</ul></li>
</ul></li>
<li>プロパティ

<ul>
<li>feed

<ul>
<li>ID

<ul>
<li>一意的にニュースを識別するためのもの</li>
</ul></li>
<li>title

<ul>
<li>見出し</li>
</ul></li>
<li>subtitle</li>
<li>author</li>
<li>date, time

<ul>
<li>発行日時 / 最終更新日時</li>
</ul></li>
</ul></li>
</ul></li>
<li>アプリケーションセマンティクスのためにプロパティを拡張することが認められている

<ul>
<li>Googleでは、マップ上のシンボル、カレンダー、スプレッドシートのセル、ビデオ用に付加的な表現を拡張している(GData)</li>
</ul></li>
</ul>

<h3>OData</h3>

<ul>
<li>AtomPubベース</li>
<li>MSが協力しているのでVisual studioから使いやすい</li>
</ul>

<h3>Hydra</h3>

<ul>
<li>あまり表舞台では見かけない</li>
</ul>

<h3>Semantics Challenge</h3>

<ul>
<li><p>ドメイン特化なフォーマットの場合(MAZE+xml)</p>

<ul>
<li>カスタムタイプ、リンクリレーションがセマンティクスギャップを埋める

<ul>
<li>カスタム定義したハイパーメディアタイプ</li>
<li>問題空間のために定義されたリンクリレーション</li>
</ul></li>
</ul></li>
<li><p>コレクションパターンは2種類のリソースタイプに大別される</p>

<ul>
<li>item-type

<ul>
<li>GET, PUT, DELETE</li>
<li>内容+ item自身へのリンクをもつ</li>
</ul></li>
<li>collection-type

<ul>
<li>GET, POST(as append)</li>
<li>item-typeリソースをメンバーとしてもつ</li>
</ul></li>
</ul></li>
<li><p>collection-typeはリンクリレーションによるナビゲーションでアプリケーションセマンティクスを定義する</p>

<ul>
<li>first, next, search</li>
</ul></li>
<li><p>item-type</p>

<ul>
<li>一般的に定義されたアプリケーションセマンティクスはない</li>
<li>Collection+JSON

<ul>
<li>item-typeリソースの意味は、prompt要素にhuman-readableな説明として記述される</li>
</ul></li>
</ul></li>
<li><p>同じドメインでも、APIが異なれば、アプリケーションセマンティクスは異なる</p>

<ul>
<li>text or content</li>
<li>post ot blogPost</li>
<li>etc,&#8230;</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-09/restful-web-api-memo-07/">RESTful Web APIs 読書メモ(7)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ESTful Web APIs 読書メモ(5)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-05/"/>
    <updated>2015-03-08T22:19:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-05</id>
    <content type="html"><![CDATA[<h2>Chapter.5 Domain-Specific Designs</h2>

<ul>
<li> ドメイン特化設計

<ul>
<li>ドメイン特化のmedia-typeではなく、一般的なmedia-typeにアプリケーションセマンティクスを加える方が良い

<ul>
<li>Aplication/vnd.xxx.Maze+XML</li>
</ul></li>
<li>API設計する際に平均的な開発者が最初に選択する</li>
<li>RFC5988

<ul>
<li>リンク間の関係を定義</li>
</ul></li>
</ul></li>
</ul>

<!-- more -->

<ul>
<li>Maze+XMLでスタート地点を得るためにAPI callメタファを使うと

<ul>
<li>迷路一覧をGET

<ul>
<li>rel=&quot;maze&quot;で対象の迷路が判明</li>
</ul></li>
<li>対象の迷路をGET

<ul>
<li>rel=&quot;start&quot;でエントランスが判明</li>
</ul></li>
<li>迷路のエントランスセルをGET

<ul>
<li>relで各方角のセルが判明</li>
</ul></li>
</ul></li>
<li>API callメタファ

<ul>
<li>サーバーの実装の詳細が露出しがちになる</li>
<li>サーバーとクライアントが密結合となる</li>
<li>APIをおいそれと修正出来なくなる</li>
</ul></li>
<li><p>ドメイン特化API</p>

<ul>
<li>作成者

<ul>
<li>human-readableな仕様を書く</li>
<li>その仕様にmedia-typeを関連付けIANAに登録する</li>
</ul></li>
<li>利用者

<ul>
<li>IANAレジストリで未知のmedia-typeを探す</li>
<li>登録された仕様を読み、利用方法を学ぶ</li>
</ul></li>
</ul></li>
<li><p>クライアント</p>

<ul>
<li>human-driven</li>
<li>clawler

<ul>
<li>全てのハイパーメディアをたどる</li>
</ul></li>
<li>script

<ul>
<li>最初に遭遇したハイパーメディアのみをたどる</li>
</ul></li>
<li>monitor

<ul>
<li>ハイパーメディアを列挙する</li>
</ul></li>
<li>agent

<ul>
<li>アルゴリズムを基づき、ハイパーメディアを取捨選択する</li>
</ul></li>
</ul></li>
<li><p>自動化されたクライアントは、ハイパーメディアAPIのメリットを最も享受できる</p>

<ul>
<li>ゴールが見えている</li>
<li>ゴールへのみちが示されている</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-06/">RESTful Web APIs 読書メモ(6)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(4)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-04/"/>
    <updated>2015-03-08T22:15:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-04</id>
    <content type="html"><![CDATA[<h2>Chapter.4 Hypermedia</h2>

<!-- more -->

<ul>
<li><p>ハイパーメディア</p>

<ul>
<li>リソースを互いに結びつけ合わせること</li>
<li>将来発行することになるリクエストをサーバーがクライアントに伝える方法</li>
<li>あたかもメニューのようなもの</li>
</ul></li>
<li><p>ハイパーメディアとしてのHTML</p>

<ul>
<li>リンクを選択すること = リンク先のリソースに&quot;visit&quot;すること

<ul>
<li>表示されたリソースを新しいリソースで置き換えること</li>
</ul></li>
<li>aタグ

<ul>
<li>あるURLに対して、リンクを選択した場合のみ発行されるGETリクエストを発行するもの</li>
<li>imgタグ

<ul>
<li>あるURLに対して、バックグラウンドで自動的にGETリクエストを発行するもの</li>
</ul></li>
<li>formタグ(method=POST)

<ul>
<li>あるURLに対して、submitした場合に、クライアントが生成したエンティティボディをもつPOSTリクエストを発行するもの</li>
</ul></li>
<li>formタグ(method=GET)

<ul>
<li>submitした場合に、クライアントが生成したクエリボディをもつURLにGETリクてを発行するもの</li>
<li>human-readableなURLは作られない</li>
<li>RFC6570, URI Templateを使うと、human-readableにできる</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>URIとURLの違い</p>

<ul>
<li>URL

<ul>
<li>リソースを見分けるための短い文字列</li>
<li>URLはURIの一種</li>
<li>RFC3986で標準化</li>
<li>何らかの表現と関連づいてる</li>
</ul></li>
<li>URI

<ul>
<li>リソースを見分けるための短い文字列</li>
<li>RFC3986で標準化</li>
<li>表現をもつ保障はない</li>
<li>URNもURIの一種</li>
</ul></li>
<li>URLなしでは、リソースを表現として得られない -&gt; REST制約を満たせない</li>
<li>URNでリンクをつくってもハイパーメディア制約を満たせない</li>
<li>URLであれば、REST制約を満たせる</li>
</ul></li>
<li><p>HTTPリクエストやレスポンスのLINKヘッダ(RFC5988)</p>

<ul>
<li>画像やただのplain textをハイパーメディアを付与する

<ul>
<li>画像であればスライドショー</li>
<li>テキストであれば、本文の続き</li>
</ul></li>
</ul></li>
<li><p>ハイパーメディアの仕事</p>

<ul>
<li>クライアントにHTTPリクエストの構築方法を伝達

<ul>
<li>aタグ: メソッド(暗黙的)とURL(明示的) を提示している</li>
<li>formタグ: メソッド、URL、送信本文を提示

<ul>
<li>encType属性を付与することでContent-Typeヘッダを提示できる</li>
</ul></li>
<li>URI Template: URLを提示</li>
</ul></li>
<li>HTTPレスポンスについての約束事をとりつける

<ul>
<li>imgタグ:

<ul>
<li>aタグ同様GETリクエストとなることを提示</li>
<li>サーバーがレスポンスとして画像を返すことを約束づけている</li>
</ul></li>
<li>AtomPubのlinkタグ

<ul>
<li>rel=&quot;edit&quot;の付与で、GETに加えPUT, DELETEのサポートを約束づけている</li>
<li>AtomPub Member Entity表現がレスポンスとして返されることを約束づけている</li>
</ul></li>
</ul></li>
<li>ワークフロー制御の提案

<ul>
<li>リソース間の関係を提示

<ul>
<li>aタグ

<ul>
<li>現在のページから指定されたURLのページに移動する</li>
<li>out-bound リンク(アプリケーション状態を変化させる) </li>
</ul></li>
<li>imgタグ

<ul>
<li>embeddedリンク(アプリケーション状態を変化させない) </li>
</ul></li>
<li>scriptタグ

<ul>
<li>表現をダウンロードし、実行</li>
</ul></li>
<li>link rel=&quot;stylesheet&quot;

<ul>
<li>スタイルシートを適用する</li>
</ul></li>
<li>framesetタグ

<ul>
<li>別のhtmlドキュメントを埋め込む</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>ハイパーメディアの偽物にご用心</p>

<ul>
<li>JSONはハイパーメディアをサポートしていない。</li>
<li>URLに見えても、仕様上、所詮ただの文字列</li>
<li>web APIのレスポンスとして生JSONを使用することはREST制約を満たせない</li>
<li>web APIのレスポンスにはハイパーメディアをサポートするmedia typeを使うべき</li>
</ul></li>
<li><p>imgタグとscriptタグもGETでリソース表現を取得する点でプロトコルセマンティクスや違いはない</p></li>
<li><p>各々のタグから導かれるアプリケーションセマンティクスに従って処理を行う</p></li>
</ul>

<h3>Semantics Challenge</h3>

<ul>
<li>Webブラウザは、人との対話を通してリンク先を決定する</li>
<li><p>いかにすれば、人の介在なしにこの振る舞いを実現できるのか？</p></li>
<li><p>HTMLのimgタグも、scriptタグも、HTTPの観点では違いはない</p>

<ul>
<li>同一のプロトコルセマンティクスを持つ</li>
<li>アプリケーションセマンティクスは異なるが・・・</li>
</ul></li>
<li><p>ドメイン特化アプリの場合、ハイパーメディアコントロールがセマンティクスギャップを埋める可能性を持つ</p>

<ul>
<li>画像収集アプリであれば、imgタグだけを踏み、scriptタグを無視する</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-05/">RESTful Web APIs 読書メモ(5)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(3)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-03/"/>
    <updated>2015-03-08T22:11:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-03</id>
    <content type="html"><![CDATA[<h2>Chapter 3. Resources and Representations</h2>

<!-- more -->

<ul>
<li>RESTは、プロトコルでもファイルフォーマットでもフレームワークでもない。</li>
<li>RESTは設計制約のセット

<ul>
<li>ステートレス</li>
<li>HATEOAS</li>
<li>などなど</li>
</ul></li>
<li><p>HTTP, URI, HTMLを理解することは、REST制約を理解するための鍵となる</p>

<ul>
<li> HTTP, URI, HTMLの根底には、リソース、表現という概念がひそんでいる</li>
<li>Clientにとって、Resourceがなにであるかは重要ではない。ClientはURLと結果の表現だけを見ているから</li>
<li>表現とは、有益な形にリソースを加工したドキュメントであり、リソースの現在の状態をクライアントで読み取れるようにしたもの</li>
</ul></li>
</ul>

<p>*GET
    * 表現の問い合わせ
 * POST, PUT, PATCH
    * 表現の提案</p>

<ul>
<li><p>リソースは一つ以上の表現をもつ</p>

<ul>
<li>言語(en, ja,&#8230;)</li>
<li>フォーマット(JSON, XML,&#8230;)</li>
<li>要約と全文</li>
</ul></li>
<li><p>クライアントからは、</p>

<ul>
<li>content negotiation</li>
<li>一つのURLに複数のURI</li>
</ul></li>
</ul>

<h3>プロトコルセマンティクス</h3>

<ul>
<li><p>リクエストメソッド</p>

<ul>
<li>GET

<ul>
<li>リソース表現を取得</li>
<li> 安全でかつ冪等</li>
<li>リソースの状態変更を期待する場面では使うべきでない</li>
<li>よく使われるレスポンスコードは200(OK) or 301(Moved permanently)</li>
<li>リソースがない場合、404(Not found)</li>
<li>リソースが削除(DELETE)されていた場合、410(Gone)</li>
</ul></li>
<li>DELETE

<ul>
<li>リソースを破棄</li>
<li>安全ではないが冪等</li>
<li>よく使われるレスポンスコードは204(No content), 200(OK), 202(Accepted: 後で削除)</li>
</ul></li>
<li>POST(to append)

<ul>
<li>指定された表現でリソースを新規作成</li>
<li>追記の場合のレスポンスコードは201(Created)</li>
<li>201は作成されたリソースのURIを示すLocationヘッダをもつ</li>
<li>作成はするがまだ完了していない場合、202(Accepted)が返される</li>
<li>安全でもなく冪等でもない</li>
</ul></li>
<li>POST(overload)

<ul>
<li>PUT, DELETEの代わりに投げつける</li>
</ul></li>
<li>PUT

<ul>
<li>リソースを置き換える</li>
<li>GETで取得し、修正してPUTで投げる</li>
<li>リクエスト内容に不備があれば、サーバーは拒否する自由がある</li>
<li>返されるステータスコードは、200(OK), 204(No content)</li>
<li>冪等である</li>
<li>既知のURLに新しいリソースを作成するためにも用いられる</li>
<li>新規リソースを作成する場合でさえ冪等</li>
</ul></li>
<li>HEAD

<ul>
<li>リソースのヘッダレスポンスのみ返す</li>
</ul></li>
<li>OPTIONS

<ul>
<li>利用できるhttpメソッドの列挙</li>
</ul></li>
<li>CONNECT, TRACE

<ul>
<li>プロキシのためのもの</li>
</ul></li>
</ul></li>
<li><p>RFC-5789</p>

<ul>
<li>PATCH

<ul>
<li>指定された表現に基づいてリソースの一部を修正する</li>
<li>PUTとは異なり微調整が可能</li>
<li>リクエストも変更対象の差分だけを送ることが可能</li>
<li>変更後のリソースをクライアントに戻す場合、200(OK)を返す</li>
<li>成功を伝えるだけであれば、304(No Content)を返す</li>
</ul></li>
</ul></li>
<li><p>標準候補だった(RFC2068で入り、2616で破棄)</p>

<ul>
<li>LINK

<ul>
<li>別のリソースとリンクを張る</li>
<li>安全ではないが冪等</li>
<li>URLはLINKヘッダで指定</li>
</ul></li>
<li>UNLINK

<ul>
<li>別のリソースとのリンクを破棄する</li>
<li> 安全ではないが冪等</li>
<li>URLはLINKヘッダで指定</li>
</ul></li>
</ul></li>
<li><p>WebDAV(RFC4918)</p>

<ul>
<li>COPY, MOVE, LOCKなど7つのメソッドを追加</li>
</ul></li>
<li><p>RESTful system</p>

<ul>
<li>独立したコンポーネント(サーバー、クライアント、キャッシュ、プロキシ)で構成されている</li>
<li>HTTPのプロトコルセマンティクスの大半はHTTPメソッドとして定義されている</li>
<li>APIをhtmlで記述する場合、メソッドはGET, POSTに制限される</li>
<li>ファイルシステムGUIアプリなら、HTTP+WebDAVのメソッドが使われるだろう</li>
<li>キャッシュやプロキシならPATCHメソッドの使用が考えられる</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-04/">RESTful Web APIs 読書メモ(4)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(2)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-02/"/>
    <updated>2015-03-08T19:53:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-02</id>
    <content type="html"><![CDATA[<h2>Chapter 2. A Simple API</h2>

<!-- more -->

<h3>GETリクエスト</h3>

<ul>
<li>リソース状態の変更は意図しない

<ul>
<li>アクセスカウンタやログ保存のような付随した事象の変更はOK</li>
</ul></li>
<li><p>安全なメソッド</p></li>
<li><p>過去にGETリクエストで、リソース状態の変更がしばしば行われていたが、これは間違った設計</p></li>
</ul>

<h3>レスポンス</h3>

<ul>
<li>status code

<ul>
<li>リクエストがどう処理されたかという結果をクライアントに知らせる</li>
</ul></li>
<li>entity-body

<ul>
<li>ドキュメント本体</li>
</ul></li>
<li>レスポンスヘッダ

<ul>
<li>entity-bodyを記述するためのKey-Valueペア</li>
<li>status codeの後、entity-bodyの前に送られる</li>
<li>content-type

<ul>
<li>どんなentity-bodyが返されたかクライアントに知らせる</li>
<li>media-type</li>
</ul></li>
</ul></li>
</ul>

<h4>JSON</h4>

<ul>
<li>APIレスポンスの表現として用いられるフォーマット(RFC4627)</li>
</ul>

<h4>Collection+JSON</h4>

<ul>
<li>Publishing APIの目的で用いることができるフォーマット</li>
<li><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-06/">6章参照</a></li>
<li>利用可能なリソースの一覧を発行するための標準</li>
<li>collection, items, valueのそれぞれにhrefプロパティをもつ</li>
<li>リスト、明細、フォームテンプレート、検索結果のいづれでも同じフォーマット</li>
<li><p>hrefと名付けられたとき、その内容はかならずURI</p></li>
<li><p>Collection+JSONを使った、itemの追加</p>

<ul>
<li>template構造に基づいて、内容を埋める

<ul>
<li>content-type: application/vnd. collection+jsonでPOSTリクエストを発行する</li>
<li>成功したら、ステータスコード201を返す</li>
<li>また、レスポンスには新しいリソースのURIを含めておく</li>
<li>新しく作成されたリソースもまたGETリクエストで取得すると、それもまた、Collection+JSON</li>
</ul></li>
</ul></li>
</ul>

<h3>POSTリクエスト</h3>

<p>（なんかまとめづらい内容なので省略）</p>

<h3>アプリケーションセマンティクスがセマンティクスギャップを作ること</h3>

<ul>
<li><p>アプリケーションセマンティクス</p>

<ul>
<li>アプリケーション特有の構造</li>
<li>media-typeのフォーマットとしては規定されていない構造</li>
</ul></li>
<li><p>標準化された、もしくは互いに合意されたアプリケーションセマンティクスであれば、セマンティクスギャップ消失する</p></li>
<li><p>あえてセマンティクスギャップを広げることで、APIに差別化をもたらすことができるかもしれない</p></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-03/">RESTful Web APIs 読書メモ(3)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful Web APIs 読書メモ(1)]]></title>
    <link href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-01/"/>
    <updated>2015-03-08T17:45:00+09:00</updated>
    <id>http://ritalin.github.io/2015/03-08/restful-web-api-memo-01</id>
    <content type="html"><![CDATA[<h2>Chapter 1. Surfing the Web</h2>

<ul>
<li>Webは分散コンピューティングの力を秘めている</li>
</ul>

<!-- more -->

<h3>Webを形作るテクノロジ</h3>

<ul>
<li>URL

<ul>
<li>リソースの識別子</li>
</ul></li>
<li>HTTPプロトコル

<ul>
<li>URLにHTTPリクエストを投げ、リソースを表現として取得する</li>
</ul></li>
<li>HTMLフォーマット</li>
</ul>

<h3>Addressability</h3>

<p>すべてのリソースが自身を時期別するURLを持つこと</p>

<h3>自己記述性メッセージ</h3>

<p>Webはリンクを介した対話を提供する</p>

<h3>標準化されたメソッド</h3>

<ul>
<li>HTTPメソッド(RFC2616)

<ul>
<li>GET

<ul>
<li>リソースの表現を交換すること

<ul>
<li>表現 = リソース状態を時にはtextで、時には画像として、求められた形で返すこと</li>
</ul></li>
</ul></li>
<li>HEAD</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
</ul></li>
</ul>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-03/">3章参照</a></p>

<h3>Application State</h3>

<p>クライアントサイドの状態</p>

<ul>
<li><p>アプリケーション状態はユーザーからのインタラクション、またはサーバーからの応答で更新されて</p></li>
<li><p>例</p>

<ul>
<li>マイクロブログに投稿する内容</li>
<li>選択したチェックボックス</li>
<li>カートの中身</li>
</ul></li>
</ul>

<h3>Resource state</h3>

<p>サーバーサイドの状態</p>

<ul>
<li><p>クライアントは直接リソース状態を制御できない</p>

<ul>
<li>クライアントに保持されるアプリケーション状態と、サーバーに保存されたリソース状態を交換することで間接的に制御</li>
</ul></li>
<li><p>例</p>

<ul>
<li>リソースに記録された内容</li>
<li>投稿された内容</li>
<li>ある日時の天気</li>
</ul></li>
</ul>

<h3>Connectedness</h3>

<p>wwwは連結性(connectedness)の原理で動いている(HATEOASと呼ばれる)</p>

<p>HATEOAS = hypermedia as the engine of application state</p>

<p>hypermedia = アプリケーション状態のエンジン = linkをクリックしたり、formから提出すること</p>

<h3>REST APIの問題点</h3>

<ul>
<li>しばしば別の、Human-readableドキュメントでAPIの利用方法が説明される

<ul>
<li>自己記述性メッセージとConnectednessの原則を破壊する</li>
</ul></li>
<li>サイトが変更されても、古いクライアントアプリでも動くよう後方互換性をもたせるべき</li>
</ul>

<h3>Semantic Challenge</h3>

<ul>
<li>Web APIの最大の挑戦

<ul>
<li>ドキュメント構造の理解と、その意味を理解することの間のセマンティクスギャップを埋めること</li>
</ul></li>
</ul>

<hr>

<h2>つづき・・・</h2>

<p><a href="http://ritalin.github.io/2015/03-08/restful-web-api-memo-02/">RESTful Web APIs 読書メモ(2)</a></p>
]]></content>
  </entry>
  
</feed>
